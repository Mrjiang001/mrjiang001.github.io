<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>爬虫基础 | Mr Jiang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一. 爬虫介绍1234567891011121314151617181) 本质：模拟发送http请求（requests）----》解析返回数据（re，bs4，lxml，json）---》入库（redis，mysql，mongodb）    #1、发起请求    使用http库向目标站点发起请求，即发送一个Request    Request包含：请求头、请求体等    #2、获取响应内容    如">
<meta property="og:type" content="article">
<meta property="og:title" content="爬虫基础">
<meta property="og:url" content="http://yoursite.com/2019/09/17/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Mr Jiang">
<meta property="og:description" content="一. 爬虫介绍1234567891011121314151617181) 本质：模拟发送http请求（requests）----》解析返回数据（re，bs4，lxml，json）---》入库（redis，mysql，mongodb）    #1、发起请求    使用http库向目标站点发起请求，即发送一个Request    Request包含：请求头、请求体等    #2、获取响应内容    如">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1843708/202004/1843708-20200408012650049-1256109781.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1843708/202004/1843708-20200408012659014-1293490793.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/1036857/201701/1036857-20170110102405447-1927945464.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/1036857/201701/1036857-20170110102650244-1301022438.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1843708/202004/1843708-20200408012711003-1461199756.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/1036857/201701/1036857-20170110105232947-533137779.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/1036857/201701/1036857-20170110105721947-1666405322.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1843708/202004/1843708-20200408214254090-901820730.png">
<meta property="article:published_time" content="2019-09-17T08:33:49.000Z">
<meta property="article:modified_time" content="2020-07-27T08:39:52.618Z">
<meta property="article:author" content="Mr Jiang">
<meta property="article:tag" content="爬虫">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2020.cnblogs.com/blog/1843708/202004/1843708-20200408012650049-1256109781.png">
  
    <link rel="alternate" href="/atom.xml" title="Mr Jiang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mr Jiang</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">头发还够，那就再多学点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-爬虫基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/17/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2019-09-17T08:33:49.000Z" itemprop="datePublished">2019-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      爬虫基础
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-爬虫介绍"><a href="#一-爬虫介绍" class="headerlink" title="一. 爬虫介绍"></a>一. 爬虫介绍</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1) 本质：模拟发送http请求（requests）----》解析返回数据（re，bs4，lxml，json）---》入库（redis，mysql，mongodb）</span><br><span class="line">    #1、发起请求</span><br><span class="line">    使用http库向目标站点发起请求，即发送一个Request</span><br><span class="line">    Request包含：请求头、请求体等</span><br><span class="line"></span><br><span class="line">    #2、获取响应内容</span><br><span class="line">    如果服务器能正常响应，则会得到一个Response</span><br><span class="line">    Response包含：html，json，图片，视频等</span><br><span class="line"></span><br><span class="line">    #3、解析内容 </span><br><span class="line">    解析html数据：正则表达式，第三方解析库如Beautifulsoup，pyquery等</span><br><span class="line">    解析json数据：json模块</span><br><span class="line">    解析二进制数据:以b的方式写入文件</span><br><span class="line"></span><br><span class="line">    #4、保存数据</span><br><span class="line">    数据库</span><br><span class="line">    文件</span><br><span class="line">2.为什么python做爬虫最好：包多，爬虫框架：scrapy：性能很高的爬虫框架，爬虫界的django，大而全（爬虫相关的东西都集成了）</span><br></pre></td></tr></table></figure>

<h2 id="二-HTTP协议回顾"><a href="#二-HTTP协议回顾" class="headerlink" title="二.HTTP协议回顾"></a>二.HTTP协议回顾</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">(1)HTTP协议，即超文本协议，基于TCP&#x2F;IP协议之上的应用层协议</span><br><span class="line"></span><br><span class="line">扩展：cs架构的软件（例如：mysql，redis，mongodb），他们的客户端（Navicate，python代码pymysql）与服务端通信都是通过底层socket实现（这就相当于自己定制的协议）， 而HTTP的底层也是socket，他的通信协议就是应用层协议。后面出现的docker和es，底层也是socket，遵循HTTP协议里的resful规范</span><br><span class="line"></span><br><span class="line">（2）基于请求－响应模式：</span><br><span class="line">客户端主动发起请求---》服务端才能响应</span><br><span class="line">服务端不能主动推送消息：了解轮询和长轮询</span><br><span class="line">轮询：某个客户端可以通过ajax不停的向服务端发送请求获取数据</span><br><span class="line">长轮询：某个客户端发送请求到服务端，但是会等待了一段时间再重新发送请求，如下图</span><br><span class="line">这样可以实现类似于服务端主动发送消息。</span><br><span class="line">websocket协议：主动推送消息</span><br><span class="line"></span><br><span class="line">（3）无状态保存（解决方法:cookie，session，token）</span><br><span class="line">    </span><br><span class="line">（4）无连接：发送一次请求，响应完就断开，性能影响</span><br><span class="line">  http协议版本：0.9，</span><br><span class="line">  http协议版本1.1和2.0的区别</span><br><span class="line">  1.1:多次请求，共用一个socket连接，</span><br><span class="line">  2.0:一次请求，可以携带多个http请求</span><br></pre></td></tr></table></figure>

<p><img src="https://img2020.cnblogs.com/blog/1843708/202004/1843708-20200408012650049-1256109781.png" alt="img"></p>
<h3 id="HTTP请求协议"><a href="#HTTP请求协议" class="headerlink" title="HTTP请求协议"></a>HTTP请求协议</h3><p><img src="https://img2020.cnblogs.com/blog/1843708/202004/1843708-20200408012659014-1293490793.png" alt="img"></p>
<p>类似这种-127.0.0.1/name=lqz&amp;age=18是放在请求首行中</p>
<p>post请求在请求体中放数据：name=lqz&amp;age=18 放在请求体中</p>
<p>问：-post请求，可以这样发么：127.0.0.1/name=lqz&amp;age=18，这样发怎么取？</p>
<p>答：django中数据通过requtes.GET获取 放在体中通过request.POST获取</p>
<p>问：请求体的格式（编码格式）：</p>
<p>urlencode:name=lqz&amp;age=18 —》request.POST json:{name:lqz,age:18} —-&gt;request.POST取不出来(为什么？django框架没有做这个事，json数据直接放在body中，可以通过drf框架等自己取出来) formdata:传文件，5g大文件， —-》request.POST</p>
<p><strong>GET请求</strong></p>
<p>HTTP默认的请求方法就是GET * 没有请求体 * 数据必须在1K之内！ * GET请求数据会暴露在浏览器的地址栏中</p>
<p>GET请求常用的操作：</p>
<ol>
<li>在浏览器的地址栏中直接给出URL，那么就一定是GET请求<ol>
<li>点击页面上的超链接也一定是GET请求<ol>
<li>提交表单时，表单默认使用GET请求，但可以设置为POST</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.sina.com.cn</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;55.0.2883.87 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Encoding: gzip, deflate, sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8</span><br><span class="line">Cookie: SINAGLOBAL&#x3D;223.71.229.3_1484011627.259786; Apache&#x3D;223.71.229.3_1484011627.259788</span><br></pre></td></tr></table></figure>

<ul>
<li><p>GET / HTTP/1.1：GET请求，请求服务器路径为 <a href="http://www.sina.com.cn/" target="_blank" rel="noopener">http://www.sina.com.cn/</a> ，协议为1.1；</p>
</li>
<li><p>Host:<a href="https://www.cnblogs.com/jiangxianseng/p/www.sina.com.cn" target="_blank" rel="noopener">www.sina.com.cn</a> 请求的主机名为<a href="https://www.cnblogs.com/jiangxianseng/p/www.sina.com.cn" target="_blank" rel="noopener">www.sina.com.cn</a>；</p>
</li>
<li><p>Connection: keep-alive：客户端支持的链接方式，保持一段时间链接，默认为3000ms；</p>
</li>
<li><p>User-Agent:…….：与浏览器和OS相关的信息。有些网站会显示用户的系统版本和浏览器版本信息，这都是通过获取User-Agent头信息而来的；</p>
</li>
<li><p>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8：告诉服务器，当前客户端可以接收的文档类型，其实这里包含了<em>/</em>，就表示什么都可以接收；</p>
</li>
<li><p>Accept-Encoding: gzip, deflate,sdch：支持的压缩格式。数据在网络上传递时，可能服务器会把数据压缩后再发送；</p>
</li>
<li><p>Accept-Language: zh-cn,zh;q=0.5：当前客户端支持的语言，可以在浏览器的工具选项中找到语言相关信息；</p>
</li>
<li><p>Cookie:SINAGLOBAL=223.71.229.3_1484011627.259786; Apache=223.71.229.3_1484011627.259788</p>
</li>
</ul>
<p>  因为不是第一次访问这个地址，所以会在请求中把上一次服务器响应中发送过来的Cookie在请求中一并发送去过；这个Cookie的名字为SINAGLOBAL</p>
<p><strong>POST请求</strong></p>
<p>(1). 数据不会出现在地址栏中 (2). 数据的大小没有上限 (3). 有请求体 (4). 请求体中如果存在中文，会使用URL编码！</p>
<p>表单测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;form method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">用户名:&lt;br&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">密码:&lt;br&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;password&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;登录&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line">表单测试</span><br></pre></td></tr></table></figure>

<p><img src="https://images2015.cnblogs.com/blog/1036857/201701/1036857-20170110102405447-1927945464.png" alt="img"></p>
<p>为什么要进行URL编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">我们都知道Http协议中参数的传输是&quot;key&#x3D;value&quot;这种简直对形式的，如果要传多个参数就需要用“&amp;”符号对键值对进行分割。如&quot;?name1&#x3D;value1&amp;name2&#x3D;value2&quot;，这样在服务端在收到这种字符串的时候，会用“&amp;”分割出每一个参数，然后再用“&#x3D;”来分割出参数值。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">针对“name1&#x3D;value1&amp;name2&#x3D;value2”我们来说一下客户端到服务端的概念上解析过程: </span><br><span class="line">  上述字符串在计算机中用ASCII吗表示为： </span><br><span class="line">  6E616D6531 3D 76616C756531 26 6E616D6532 3D 76616C756532。 </span><br><span class="line">   6E616D6531：name1 </span><br><span class="line">   3D：&#x3D; </span><br><span class="line">   76616C756531：value1 </span><br><span class="line">   26：&amp;</span><br><span class="line">   6E616D6532：name2 </span><br><span class="line">   3D：&#x3D; </span><br><span class="line">   76616C756532：value2 </span><br><span class="line">   服务端在接收到该数据后就可以遍历该字节流，首先一个字节一个字节的吃，当吃到3D这字节后，服务端就知道前面吃得字节表示一个key，再想后吃，如果遇到26，说明从刚才吃的3D到26子节之间的是上一个key的value，以此类推就可以解析出客户端传过来的参数。</span><br><span class="line"></span><br><span class="line">   现在有这样一个问题，如果我的参数值中就包含&#x3D;或&amp;这种特殊字符的时候该怎么办。 </span><br><span class="line">比如说“name1&#x3D;value1”,其中value1的值是“va&amp;lu&#x3D;e1”字符串，那么实际在传输过程中就会变成这样“name1&#x3D;va&amp;lu&#x3D;e1”。我们的本意是就只有一个键值对，但是服务端会解析成两个键值对，这样就产生了奇异。</span><br><span class="line"></span><br><span class="line">如何解决上述问题带来的歧义呢？解决的办法就是对参数进行URL编码 </span><br><span class="line">   URL编码只是简单的在特殊字符的各个字节前加上%，例如，我们对上述会产生奇异的字符进行URL编码后结果：“name1&#x3D;va%26lu%3D”，这样服务端会把紧跟在“%”后的字节当成普通的字节，就是不会把它当成各个参数或键值对的分隔符。</span><br></pre></td></tr></table></figure>

<p>POST请求是可以有体的，而GET请求不能有请求体。</p>
<p><img src="https://images2015.cnblogs.com/blog/1036857/201701/1036857-20170110102650244-1301022438.png" alt="img"></p>
<ul>
<li><strong>Referer</strong>: <a href="http://localhost:63342/test/test.html：请求来自哪个页面，例如你在百度上点击链接到了这里，那么Referer:[http://www.baidu.com](http://www.baidu.com/)；如果你是在浏览器的地址栏中直接输入的地址，那么就没有Referer这个请求头了；" target="_blank" rel="noopener">http://localhost:63342/test/test.html：请求来自哪个页面，例如你在百度上点击链接到了这里，那么Referer:[http://www.baidu.com](http://www.baidu.com/)；如果你是在浏览器的地址栏中直接输入的地址，那么就没有Referer这个请求头了；</a></li>
<li>Content-Type: application/x-www-form-urlencoded：表单的数据类型，说明会使用url格式编码数据；url编码的数据都是以“%”为前缀，后面跟随两位的16进制。</li>
<li>Content-Length:49：请求体的长度，这里表示13个字节。</li>
<li>username=‘林海峰’：请求体内容！hello是在表单中输入的数据，keyword是表单字段的名字</li>
</ul>
<p>Referer的应用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Referer请求头是比较有用的一个请求头，它可以用来做统计工作，也可以用来做防盗链。</span><br><span class="line">统计工作：我公司网站在百度上做了广告，但不知道在百度上做广告对我们网站的访问量是否有影响，那么可以对每个请求中的Referer进行分析，如果Referer为百度的很多，那么说明用户都是通过百度找到我们公司网站的。</span><br><span class="line">防盗链：我公司网站上有一个下载链接，而其他网站盗链了这个地址，例如在我网站上的index.html页面中有一个链接，点击即可下载JDK7.0，但有某个人的微博中盗链了这个资源，它也有一个链接指向我们网站的JDK7.0，也就是说登录它的微博，点击链接就可以从我网站上下载JDK7.0，这导致我们网站的广告没有看，但下载的却是我网站的资源。这时可以使用Referer进行防盗链，在资源被下载之前，我们对Referer进行判断，如果请求来自本网站，那么允许下载，如果非本网站，先跳转到本网站看广告，然后再允许下载。</span><br></pre></td></tr></table></figure>

<h3 id="HTTP响应协议"><a href="#HTTP响应协议" class="headerlink" title="HTTP响应协议"></a>HTTP响应协议</h3><p><img src="https://img2020.cnblogs.com/blog/1843708/202004/1843708-20200408012711003-1461199756.png" alt="img"></p>
<p>响应内容是由服务器发送给浏览器的内容，浏览器会根据响应内容来显示。遇到<img src=''>会开一个新的线程加载，所以有时图片多的话，内容会先显示出来，然后图片才一张张加载出来。 wsgi server</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#_*_coding:utf-8_*_</span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from wsgiref.simple_server import make_server</span><br><span class="line"># 定义application函数:</span><br><span class="line">def application(environ, start_response):</span><br><span class="line">    print(environ)</span><br><span class="line">    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text&#x2F;html&#39;)])</span><br><span class="line"></span><br><span class="line">    f&#x3D;open(&#39;test.html&#39;,&#39;rb&#39;)</span><br><span class="line">    return [f.read()]</span><br><span class="line"></span><br><span class="line"># 创建一个服务器，IP地址为空，端口是8000，处理函数是application:</span><br><span class="line">httpd &#x3D; make_server(&#39;&#39;, 8000, application)</span><br><span class="line">print(&#39;Serving HTTP on port 8000...&#39;)</span><br><span class="line"># 开始监听HTTP请求:</span><br><span class="line">httpd.serve_forever()</span><br></pre></td></tr></table></figure>

<p>test.html</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;form&gt;</span><br><span class="line">用户名:&lt;br&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">密码:&lt;br&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;password&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;登录&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line">test.html</span><br></pre></td></tr></table></figure>

<p><img src="https://images2015.cnblogs.com/blog/1036857/201701/1036857-20170110105232947-533137779.png" alt="img"></p>
<ul>
<li>HTTP/1.1 200 OK：响应协议为HTTP1.1，状态码为200，表示请求成功，OK是对状态码的解释；</li>
<li>Server:WSGIServer/0.2 CPython/3.6.0：服务器的版本信息；</li>
<li>Content-Type: text/html;charset=UTF-8：响应体使用的编码为UTF-8；</li>
<li>Content-Length: 217：响应体为217字节；</li>
<li>Set-Cookie: JSESSIONID=C97E2B4C55553EAB46079A4F263435A4; Path=/hello：响应给客户端的Cookie；</li>
<li>Date: Wed, 25 Sep 2012 04:15:03 GMT：响应的时间，这可能会有8小时的时区差；</li>
<li>Cache-Control:缓存控制</li>
</ul>
<p><strong>状态码</strong></p>
<p>响应头对浏览器来说很重要，它说明了响应的真正含义。例如200表示响应成功了，302表示重定向，这说明浏览器需要再发一个新的请求。</p>
<ul>
<li><p>200：请求成功，浏览器会把响应体内容（通常是html）显示在浏览器中；</p>
</li>
<li><p>404：请求的资源没有找到，说明客户端错误的请求了不存在的资源；</p>
</li>
<li><p>500：请求资源找到了，但服务器内部出现了错误；</p>
</li>
<li><p>302：重定向，当响应码为302时，表示服务器要求浏览器重新再发一个请求，服务器会发送一个响应头Location，它指定了新请求的URL地址；</p>
</li>
<li><p>304：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">当用户第一次请求index.html时，服务器会添加一个名为Last-Modified响应头，这个头说明了</span><br><span class="line">index.html的最后修改时间，浏览器会把index.html内容，以及最后响应时间缓存下来。当用户第</span><br><span class="line">二次请求index.html时，在请求中包含一个名为If-Modified-Since请求头，它的值就是第一次请</span><br><span class="line">求时服务器通过Last-Modified响应头发送给浏览器的值，即index.html最后的修改时间，</span><br><span class="line">If-Modified-Since请求头就是在告诉服务器，我这里浏览器缓存的index.html最后修改时间是这个,</span><br><span class="line">您看看现在的index.html最后修改时间是不是这个，如果还是，那么您就不用再响应这个index.html</span><br><span class="line">内容了，我会把缓存的内容直接显示出来。而服务器端会获取If-Modified-Since值，与index.html</span><br><span class="line">的当前最后修改时间比对，如果相同，服务器会发响应码304，表示index.html与浏览器上次缓存的相</span><br><span class="line">同，无需再次发送，浏览器可以显示自己的缓存页面，如果比对不同，那么说明index.html已经做了修</span><br><span class="line">改，服务器会响应200。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/1036857/201701/1036857-20170110105721947-1666405322.png" alt="img"></p>
<p><strong>其他响应头</strong></p>
<p>告诉浏览器不要缓存的响应头：</p>
<ul>
<li>Expires: -1；</li>
<li>Cache-Control: no-cache；</li>
<li>Pragma: no-cache；</li>
</ul>
<p>自动刷新响应头，浏览器会在3秒之后请求<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com</a>：</p>
<ul>
<li>Refresh: 3;url=<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com</a></li>
</ul>
<p><strong>HTML中指定响应头</strong></p>
<p>在HTMl页面中可以使用<meta http-equiv="" content="">来指定响应头，例如在index.html页面中给出<meta http-equiv="Refresh" content="3;url=http://www.baidu.com">，表示浏览器只会显示index.html页面3秒，然后自动跳转到<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com</a>.</p>
<p><strong>响应体</strong></p>
<p>响应体中可以使html格式或者json格式</p>
<h3 id="浏览器调试"><a href="#浏览器调试" class="headerlink" title="浏览器调试"></a>浏览器调试</h3><p>-右键检查–》调试模式</p>
<p>-elements：响应体，html格式 -console：调试窗口（js输出的内容，在这能看到） -network：发送的所有请求，all xhr：ajax请求</p>
<p><strong>补充:</strong></p>
<p>爬虫协议： 在url后面加上/robots.txt即可看到 网站哪些信息允许获取和不允许获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.baidu.com&#x2F;robots.txt</span><br></pre></td></tr></table></figure>

<p><img src="https://img2020.cnblogs.com/blog/1843708/202004/1843708-20200408214254090-901820730.png" alt="img"></p>
<p>RPC介绍</p>
<p><a href="https://www.jianshu.com/p/7d6853140e13" target="_blank" rel="noopener">https://www.jianshu.com/p/7d6853140e13</a></p>
<p>消息队列</p>
<p><a href="https://www.jianshu.com/p/36a7775b04ec" target="_blank" rel="noopener">https://www.jianshu.com/p/36a7775b04ec</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/17/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/" data-id="ckd49wrd4001jl4ut10nv1rf6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/09/18/request%E6%A8%A1%E5%9D%97/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          request模块
        
      </div>
    </a>
  
  
    <a href="/2019/01/02/Django%E6%A1%86%E6%9E%B6%E4%B9%8BAjax/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Django框架之Ajax</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django/" rel="tag">Django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">网络和并发编程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Django/" style="font-size: 16.67px;">Django</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/MySQL/" style="font-size: 13.33px;">MySQL</a> <a href="/tags/Python/" style="font-size: 20px;">Python</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 10px;">爬虫</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">网络和并发编程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/28/Docker%E9%95%9C%E5%83%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/">Docker镜像容器操作</a>
          </li>
        
          <li>
            <a href="/2020/03/27/Docker/">Docker</a>
          </li>
        
          <li>
            <a href="/2019/09/18/request%E6%A8%A1%E5%9D%97/">request模块</a>
          </li>
        
          <li>
            <a href="/2019/09/17/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/">爬虫基础</a>
          </li>
        
          <li>
            <a href="/2019/01/02/Django%E6%A1%86%E6%9E%B6%E4%B9%8BAjax/">Django框架之Ajax</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Mr Jiang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>