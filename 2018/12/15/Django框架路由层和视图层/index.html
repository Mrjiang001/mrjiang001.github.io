<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Django框架路由层和视图层 | Mr Jiang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一.Django框架中rom的表关系创建1).表与表的关系 一对一  一对多  多对多 具体sql语句及关系请查看[数据库基础链接](https:&#x2F;&#x2F;www.cnblogs.com&#x2F;jiangxianseng&#x2F;p&#x2F; https:&#x2F;&#x2F;www.cnblogs.com&#x2F;jiangxianseng&#x2F;p&#x2F;12031335.html )   2)以图书管理系统为例，创建几张关系表  注意：**在models.">
<meta property="og:type" content="article">
<meta property="og:title" content="Django框架路由层和视图层">
<meta property="og:url" content="http://yoursite.com/2018/12/15/Django%E6%A1%86%E6%9E%B6%E8%B7%AF%E7%94%B1%E5%B1%82%E5%92%8C%E8%A7%86%E5%9B%BE%E5%B1%82/index.html">
<meta property="og:site_name" content="Mr Jiang">
<meta property="og:description" content="一.Django框架中rom的表关系创建1).表与表的关系 一对一  一对多  多对多 具体sql语句及关系请查看[数据库基础链接](https:&#x2F;&#x2F;www.cnblogs.com&#x2F;jiangxianseng&#x2F;p&#x2F; https:&#x2F;&#x2F;www.cnblogs.com&#x2F;jiangxianseng&#x2F;p&#x2F;12031335.html )   2)以图书管理系统为例，创建几张关系表  注意：**在models.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014522821-1473613271.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014530203-264805306.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014543536-921336729.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014555174-1256716299.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014603374-2108214149.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014648245-1772988687.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014657338-918332767.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014704103-1196569104.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014715369-693269142.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014722547-1188946840.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014730727-809963832.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014736707-179633408.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014823558-1409170796.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014900857-48030859.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014955847-821524009.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015009858-2005594121.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015022288-11967212.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015031571-737893503.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015051134-2070155243.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015223134-2054748520.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015242858-730497930.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015257097-658719102.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015313343-1932884372.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015319807-385254209.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015329861-74562135.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015350849-487608561.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015405563-1384343011.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015411423-503214024.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015418697-1926595043.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015423686-1432951746.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015441969-103073430.png">
<meta property="og:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015452327-509882785.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1843708/202005/1843708-20200528004835109-1203781986.png">
<meta property="article:published_time" content="2018-12-15T13:11:33.000Z">
<meta property="article:modified_time" content="2020-07-26T17:59:08.558Z">
<meta property="article:author" content="Mr Jiang">
<meta property="article:tag" content="Django">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014522821-1473613271.png">
  
    <link rel="alternate" href="/atom.xml" title="Mr Jiang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mr Jiang</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">头发还够，那就再多学点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Django框架路由层和视图层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/15/Django%E6%A1%86%E6%9E%B6%E8%B7%AF%E7%94%B1%E5%B1%82%E5%92%8C%E8%A7%86%E5%9B%BE%E5%B1%82/" class="article-date">
  <time datetime="2018-12-15T13:11:33.000Z" itemprop="datePublished">2018-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Django框架路由层和视图层
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-Django框架中rom的表关系创建"><a href="#一-Django框架中rom的表关系创建" class="headerlink" title="一.Django框架中rom的表关系创建"></a>一.Django框架中rom的表关系创建</h2><h3 id="1-表与表的关系"><a href="#1-表与表的关系" class="headerlink" title="1).表与表的关系"></a>1).表与表的关系</h3><ul>
<li><p>一对一</p>
</li>
<li><p>一对多</p>
</li>
<li><p>多对多</p>
<p>具体sql语句及关系请查看[数据库基础链接](<a href="https://www.cnblogs.com/jiangxianseng/p/" target="_blank" rel="noopener">https://www.cnblogs.com/jiangxianseng/p/</a> <a href="https://www.cnblogs.com/jiangxianseng/p/12031335.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiangxianseng/p/12031335.html</a> )</p>
</li>
</ul>
<h3 id="2-以图书管理系统为例，创建几张关系表"><a href="#2-以图书管理系统为例，创建几张关系表" class="headerlink" title="2)以图书管理系统为例，创建几张关系表"></a>2)以图书管理系统为例，创建几张关系表</h3><p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014522821-1473613271.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014530203-264805306.png" alt="img"></p>
<p>注意：**在models.py中书写表关系的时候，要先写好基表，再写外键关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> 1 # 先建立好三张基表</span><br><span class="line"> 2 from django.db import models</span><br><span class="line"> 3 </span><br><span class="line"> 4 # Create your models here.</span><br><span class="line"> 5 #书表</span><br><span class="line"> 6 class Book(models.Model):</span><br><span class="line"> 7     # id 是自动创建的，除非id名自定义</span><br><span class="line"> 8     title &#x3D; models.CharField(max_length&#x3D;255)</span><br><span class="line"> 9     # price为小数字段，表示总共8位数，其中小数占2位</span><br><span class="line">10     price &#x3D; models.DecimalField(max_digits&#x3D;8, decimal_places&#x3D;2)</span><br><span class="line">11 </span><br><span class="line">12 </span><br><span class="line">13 #出版社表</span><br><span class="line">14 class Publsh(models.Model):</span><br><span class="line">15     name &#x3D; models.CharField(max_length&#x3D;64)</span><br><span class="line">16     addr &#x3D; models.CharField(max_length&#x3D;64)</span><br><span class="line">17 </span><br><span class="line">18 </span><br><span class="line">19 # 作者表</span><br><span class="line">20 class Author(models.Model):</span><br><span class="line">21     name &#x3D; models.CharField(max_length&#x3D;64)</span><br><span class="line">22     # 比Int类型长一些</span><br><span class="line">23     phone &#x3D; models.BigIntegerField()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>图书表</p>
<p>图书和出版社是一对多的关系</p>
<p>外键字段应该建立在多的一方</p>
</li>
</ul>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014543536-921336729.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 1 #书表</span><br><span class="line"> 2 class Book(models.Model):</span><br><span class="line"> 3     # id 是自动创建的，除非id名自定义</span><br><span class="line"> 4     title &#x3D; models.CharField(max_length&#x3D;255)</span><br><span class="line"> 5     # price为小数字段，表示总共8位数，其中小数占2位</span><br><span class="line"> 6     price &#x3D; models.DecimalField(max_digits&#x3D;8, decimal_places&#x3D;2)</span><br><span class="line"> 7     # 书籍表和出版社表是一对多关系，外键字段要建立在书籍表中</span><br><span class="line"> 8     Publish &#x3D; models.ForeignKey(to&#x3D;&#39;Publish&#39;) # 并且默认关联字段就是出版社表的主键字段，里面有个to_field参数能够修改关联的字段</span><br><span class="line"> 9     # 补充：to后面需要加引号，若Publish表在Book表上方，则不需要加引号</span><br><span class="line">10     # Publish &#x3D; models.ForeignKey(to&#x3D;Publish)</span><br><span class="line">11 </span><br><span class="line">12     # 书籍与作者是多对多关系,外键字段建立在较为频繁的书籍表中，通过ManytoManyField方法就能建立第三张表</span><br><span class="line">13     Authors &#x3D; models.ManyToManyField(to&#x3D;&#39;Author&#39;)</span><br><span class="line">14     # 补充注意：Authors字段只是一个虚拟字段，并不会在Book表中创建出来，只是告诉Django ORM为多对多关系创建一个第三方表</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<ul>
<li>出版社表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 #出版社表</span><br><span class="line">2 class Publish(models.Model):</span><br><span class="line">3     name &#x3D; models.CharField(max_length&#x3D;64)</span><br><span class="line">4     addr &#x3D; models.CharField(max_length&#x3D;64)</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<ul>
<li><p>作者表</p>
<p>图书表与作者表是多对多的关系</p>
<p>理论上外键字段在哪张表都一样，但是推荐外键字段建立在查询较为频繁的表中</p>
</li>
</ul>
<p>作者表与作者详情表是一对一关系</p>
<p>同样，还是推荐将外键字段建立在使用频率较高的表中</p>
<p>原因：就是为了方便后面我们基于ORM查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 作者表</span><br><span class="line">class Author(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;64)</span><br><span class="line">    # 比Int类型长一些</span><br><span class="line">    phone &#x3D; models.BigIntegerField()</span><br><span class="line"></span><br><span class="line">    # 作者表与作者详情表一对一关系</span><br><span class="line">    Author_detail &#x3D; models.OneToOneField(to&#x3D;&#39;AuthorDetail&#39;)</span><br></pre></td></tr></table></figure>

<ul>
<li>作者详情表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 # 作者详情表</span><br><span class="line">2 class AuthorDetail(models.Model):</span><br><span class="line">3     age &#x3D; models.IntegerField()</span><br><span class="line">4     addr &#x3D; models.CharField(max_length&#x3D;64)</span><br></pre></td></tr></table></figure>

<h3 id="3-开始创建"><a href="#3-开始创建" class="headerlink" title="3)开始创建"></a>3)开始创建</h3><p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014555174-1256716299.png" alt="img"></p>
<h3 id="4）查看"><a href="#4）查看" class="headerlink" title="4）查看"></a>4）查看</h3><p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014603374-2108214149.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014648245-1772988687.png" alt="img"></p>
<p> <img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014657338-918332767.png" alt="img"></p>
<p>下载之后点一下apply，将新出现的数据库链接删除，重新点一下db.sqlite3,就会出现数据库了</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014704103-1196569104.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014715369-693269142.png" alt="img"></p>
<h2 id="二-Django请求生命周期流程图"><a href="#二-Django请求生命周期流程图" class="headerlink" title="二.Django请求生命周期流程图"></a>二.Django请求生命周期流程图</h2><p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014722547-1188946840.png" alt="img"></p>
<h2 id="三-路由层"><a href="#三-路由层" class="headerlink" title="三.路由层"></a>三.路由层</h2><p>一般我们刚创建好的Django框架中的urls.py里面存放的是总路由，即总的路由和视图函数或app的对应关系</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014730727-809963832.png" alt="img"></p>
<p>由上面我们可以得到：</p>
<p>url方法第一个参数是一个正则表达式，路由匹配按照正则匹配， 一旦正则能够匹配到内容 会立刻执行对应的视图函数，不会再继续匹配了</p>
<p>注意：用户输入url尾缀路由若没有加最后的斜杠，django会默认将斜杠加上，看下图（将urls中的路由加上/）</p>
<p><strong>补充：</strong>你可以在配置文件settings中指定是否开启该功能<strong>APPEND_SLASH = True/False</strong>（默认是True处于打开状态，改为False则失效）</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014736707-179633408.png" alt="img"></p>
<p>补充：网站首页一打开是非常不友好的，可以通过正则（^$)设置一下<img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014823558-1409170796.png" alt="img"></p>
<h3 id="1-无名分组和有名分组"><a href="#1-无名分组和有名分组" class="headerlink" title="1.无名分组和有名分组"></a>1.无名分组和有名分组</h3><p>基于路由层的路由是由正则表达式写的，我们可以在表达式后面来一个数字，如下,表示test后面必须加上四个一到九的数字才能访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r&#39;^test&#x2F;[0-9]&#123;4&#125;&#39;, views.test),</span><br></pre></td></tr></table></figure>

<p>但是，如果给正则表达式加一个括号，就表示分组的意思</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r&#39;^testadd&#x2F;([0-9]&#123;4&#125;)&#39;, views.testadd),</span><br></pre></td></tr></table></figure>

<p>会产生下面的报错信息</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014900857-48030859.png" alt="img"></p>
<p>解决方法：</p>
<p>在视图函数中给一个形参接收这个数字就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def testadd(request, xxx):</span><br><span class="line">    return HttpResponse(&#39;testadd&#39;)</span><br></pre></td></tr></table></figure>

<h4 id="什么叫无名分组？"><a href="#什么叫无名分组？" class="headerlink" title="什么叫无名分组？"></a>什么叫无名分组？</h4><p>在路由匹配的时候给某段正则表达式加了括号，匹配的时候会将括号内的正则表达式匹配到的内容当作位置参数传递给对应的视图函数，因此视图函数就要多准备一个形参去接收这个位置参数</p>
<h4 id="什么叫有名分组？"><a href="#什么叫有名分组？" class="headerlink" title="什么叫有名分组？"></a>什么叫有名分组？</h4><p>给一段正则表达式起一个别名  匹配的时候会将括号内正则表达式匹配到的内容当做关键字参数传递给对应的视图函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#有名分组</span><br><span class="line"># \d+表示一个或多个数字，?P&lt;ttt&gt;固定写法，表示给正则表达式命名为ttt</span><br><span class="line">    url(r&#39;^testadd&#x2F;(?P&lt;ttt&gt;\d+)&#39;, views.testadd)</span><br></pre></td></tr></table></figure>



<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107014955847-821524009.png" alt="img"></p>
<p><strong>解决方法:</strong>在视图函数中添加关键字形参去接收关键字实参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ttt就是接收关键字参数的</span><br><span class="line">def testadd(request, ttt):</span><br><span class="line">    return HttpResponse(&#39;testadd&#39;)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><strong>无名有名不能混合使用</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url(r&#39;^test&#x2F;(\d+)&#x2F;(?P&lt;year&gt;\d+)&#x2F;&#39;, views.test)</span><br><span class="line"># 会报找不到位置参数的错误</span><br></pre></td></tr></table></figure>

<ul>
<li>无名有名虽然不能混合使用，但是同一种命名方式 可以使用多个</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 #无名叠加</span><br><span class="line">2 url(r&#39;^test&#x2F;(\d+)&#x2F;(\d+)&#x2F;&#39;,views.test)</span><br><span class="line">3 </span><br><span class="line">4 #有名叠加</span><br><span class="line">5 url(r&#39;^test&#x2F;(?P&lt;xxx&gt;\d+)&#x2F;(?P&lt;year&gt;\d+)&#x2F;&#39;,views.test),</span><br></pre></td></tr></table></figure>

<h3 id="2-反向解析"><a href="#2-反向解析" class="headerlink" title="2.反向解析"></a>2.反向解析</h3><p><strong>通过一些方法 能够得到一个结果 该结果可以访问到对应的url</strong></p>
<p>例如：可以通过html页面访问另一个url页面</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015009858-2005594121.png" alt="img"></p>
<p>但是，如果将urls中的test名修改了，后面的html所有关于这个的url链接都将失效</p>
<p><strong>如何解决此问题？</strong></p>
<ul>
<li><p>第一步：</p>
<p>先给路由与视图函数对应关系 起一个名字（相当于赋予一个令牌）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r&#39;^test&#x2F;&#39;,views.testadd,name&#x3D;&#39;add&#39;)</span><br></pre></td></tr></table></figure>

<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015022288-11967212.png" alt="img"></p>
<ul>
<li>第二步：若是前端解析，将｛% url ‘add’ %｝添加html中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;&#123;% url &#39;add&#39; %&#125;&quot;&gt;2222&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015031571-737893503.png" alt="img"></p>
<ul>
<li>第三不：若是后端解析，<strong>先在view.py导入reverse模块</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 1 url(r&#39;^test&#x2F;&#39;,views.testadd,name&#x3D;&#39;add&#39;)</span><br><span class="line"> 2 </span><br><span class="line"> 3 </span><br><span class="line"> 4 from django.shortcuts import  reverse</span><br><span class="line"> 5 </span><br><span class="line"> 6 def test(request):</span><br><span class="line"> 7     _url &#x3D; reverse(&#39;add&#39;)</span><br><span class="line"> 8     print(_url)</span><br><span class="line"> 9     </span><br><span class="line">10 # 通过reverse 模块就能拿到test路由名  </span><br><span class="line">11 # &#x2F;test&#x2F;</span><br><span class="line">12 # 注意：一定要提前命名name，否则reverse会找不到</span><br></pre></td></tr></table></figure>

<h3 id="3-有名无名反向解析"><a href="#3-有名无名反向解析" class="headerlink" title="3.有名无名反向解析"></a>3.有名无名反向解析</h3><p>分析：先在urls.py文件中建立有名无名分组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 无名分组</span><br><span class="line">url(r&#39;^testadd&#x2F;([0-9]&#123;4&#125;)&#39;, views.testadd， name&#x3D;&#39;add&#39;),</span><br><span class="line">    </span><br><span class="line"> #有名分组</span><br><span class="line">url(r&#39;^test&#x2F;(?P&lt;ttt&gt;\d+)&#39;, views.test),</span><br></pre></td></tr></table></figure>

<p>然后views中导入reverse模块，运行home函数</p>
<ul>
<li>无名后端反向解析</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> 1 from django.shortcuts import render, HttpResponse, redirect, reverse</span><br><span class="line"> 2 </span><br><span class="line"> 3 def test(request, ttt):</span><br><span class="line"> 4     return HttpResponse(&#39;test&#39;)</span><br><span class="line"> 5 </span><br><span class="line"> 6 </span><br><span class="line"> 7 def testadd(request, xxx):</span><br><span class="line"> 8     return HttpResponse(&#39;testadd&#39;)</span><br><span class="line"> 9 </span><br><span class="line">10 </span><br><span class="line">11 def home(request):   </span><br><span class="line">12     _url &#x3D; reverse(&#39;add&#39;)</span><br><span class="line">13     print(_url)</span><br><span class="line">14     return HttpResponse(&#39;欢迎欢迎&#39;)</span><br></pre></td></tr></table></figure>

<p>运行后会报错，表示查找add时缺一个参数</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015051134-2070155243.png" alt="img"></p>
<p><strong>报错原因：</strong> 访问这条url：<code>url(r&#39;^testadd/([0-9]{4})&#39;, views.testadd， name=&#39;add&#39;)</code></p>
<p>必须以/testadd/1234/这种形式，否则无法访问，因此结果的不确定性让Django无法做判断，因此需要人为的给予数字</p>
<p>解决方案：在<code>_url = reverse(&#39;add&#39;)</code>中随意给一个数字，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_url &#x3D; reverse(&#39;add&#39;, args&#x3D;(1234,))</span><br><span class="line"># 注意：此处要以元组的形式添加</span><br><span class="line">#补充：这个数字通常就是数据的主键值</span><br></pre></td></tr></table></figure>

<p>再次启动访问home的url就能得到<strong>/testadd/1234</strong>，通过他就能访问testadd这条url了</p>
<ul>
<li>无名前端反向解析</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def home(request):</span><br><span class="line">    return render(request, &#39;home.html&#39;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;!--同样需要根据正则分组规则添加相应的数字--&gt;</span><br><span class="line">2 </span><br><span class="line">3 &lt;a href&#x3D;&quot;&#123;% url &#39;add&#39; 1234 %&#125;&quot;&gt;2222&lt;&#x2F;a&gt;</span><br><span class="line">4 &lt;a href&#x3D;&quot;&#123;% url &#39;add&#39; 5628 %&#125;&quot;&gt;2222&lt;&#x2F;a&gt;</span><br><span class="line">5 &lt;a href&#x3D;&quot;&#123;% url &#39;add&#39; 3637 %&#125;&quot;&gt;2222&lt;&#x2F;a&gt;</span><br><span class="line">6 &lt;a href&#x3D;&quot;&#123;% url &#39;add&#39; 3839 %&#125;&quot;&gt;2222&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015223134-2054748520.png" alt="img"></p>
<p>同上可以获得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#　有名分组</span><br><span class="line">url(r&#39;^test&#x2F;(?P&lt;ttt&gt;\d+)&#39;, views.test)</span><br></pre></td></tr></table></figure>

<ul>
<li>有名后端反向解析</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 # 在reverse中添加kwargs&#x3D;｛‘名字’：符合正则的符号｝</span><br><span class="line">2 def home(request):   </span><br><span class="line">3     _url &#x3D; reverse(&#39;add&#39;, kwargs&#x3D;&#123;&#39;year&#39;:11&#125;)  # 标准写法</span><br><span class="line">4     _url &#x3D; reverse(&#39;add&#39;, args&#x3D;(11,)</span><br><span class="line">5     print(_url)</span><br><span class="line">6     return HttpResponse(&#39;欢迎欢迎&#39;)</span><br></pre></td></tr></table></figure>

<ul>
<li>有名前端反向解析</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% url &#39;add&#39; 1 %&#125;  # 推荐使用</span><br><span class="line">&#123;% url &#39;add&#39; year&#x3D; 1 %&#125;  # 标准的</span><br></pre></td></tr></table></figure>

<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 # 无名分组反向解析：</span><br><span class="line">2 </span><br><span class="line">3 url(r&#39;^testadd&#x2F;(\d+)&#x2F;&#39;,views.testadd,name&#x3D;&#39;add&#39;)</span><br><span class="line">4         #前端解析</span><br><span class="line">5             &#123;% url &#39;add&#39; 1 %&#125;</span><br><span class="line">6         #后端解析</span><br><span class="line">7             reverse(&#39;add&#39;,args&#x3D;(12,))</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 1 有名分组反向解析：</span><br><span class="line"> 2 </span><br><span class="line"> 3 url(r&#39;^testadd&#x2F;(\d+)&#x2F;&#39;,views.testadd,name&#x3D;&#39;add&#39;)</span><br><span class="line"> 4 </span><br><span class="line"> 5 #前端解析</span><br><span class="line"> 6 &#123;% url &#39;add&#39; 1 %&#125;  # 推荐使用</span><br><span class="line"> 7 &#123;% url &#39;add&#39; year &#x3D; 1&#125; # 标准使用</span><br><span class="line"> 8 #后端解析</span><br><span class="line"> 9 _url &#x3D; reveerse(&#39;add&#39;, args&#x3D;(11,) # 推荐使用</span><br><span class="line">10 _url &#x3D; reveerse(&#39;add&#39;, kwargs&#x3D;&#123;&#39;year&#39;:11&#125; # 标准使用</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#伪代码</span><br><span class="line">url(r&#39;^edit_user&#x2F;(\d+)&#x2F;&#39;,views.edit_user,names&#x3D;&#39;edit&#39;)</span><br><span class="line"></span><br><span class="line">    &#123;% for user_obj in user_queryset %&#125;</span><br><span class="line">        &lt;a href&#x3D;&quot;edit_user&#x2F;&#123;&#123; user_obj.id &#125;&#125;&#x2F;&quot;&gt;编辑&lt;&#x2F;a&gt;</span><br><span class="line">        &lt;a href&#x3D;&quot;&#123;% url &#39;edit&#39; user_obj.id %&#125;&quot;&gt;编辑&lt;&#x2F;a&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"> def edit_user(request,edit_id):</span><br><span class="line">        reverse(&#39;edit&#39;,args&#x3D;(edit_id,))</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="4-路由分发"><a href="#4-路由分发" class="headerlink" title="4.路由分发"></a>4.路由分发</h3><h4 id="1-什么是路由分发？"><a href="#1-什么是路由分发？" class="headerlink" title="1).什么是路由分发？"></a>1).什么是路由分发？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    当django项目比较庞大的时候 路由与视图函数对应关系较多</span><br><span class="line">总路由代码太多冗长</span><br><span class="line">考虑到总路由代码不好维护 django支持每个app都可以有自己的urls.py</span><br><span class="line">并且总路由不再做路由与视图函数的对应关系 而仅仅只做一个分发任务的操作</span><br><span class="line"></span><br><span class="line">根据请求的不同 识别出当前请求需要访问的功能属于哪个app然后自动</span><br><span class="line">下发到对应app里面的urls.py中 然后由app里面的urls.py做路由与视图函数的匹配</span><br><span class="line"></span><br><span class="line">不仅如此每个app除了可以有自己的urls.py之外 还可以有自己的static文件夹 templates模板文件</span><br><span class="line">基于上面的特点 基于django分小组开发 会变得额外的简单</span><br><span class="line">每个人只需要开发自己的app即可 之后只需要创建一个空的django项目</span><br><span class="line">将多个人的app全部拷贝项目下 配置文件注册</span><br><span class="line">总路由分发一次</span><br></pre></td></tr></table></figure>

<h4 id="2-如何实现一个简单的路由分发"><a href="#2-如何实现一个简单的路由分发" class="headerlink" title="2).如何实现一个简单的路由分发"></a>2).如何实现一个简单的路由分发</h4><p>第一步：在控制台通过命令行创建多个app文件夹，并将app在settings中注册</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015242858-730497930.png" alt="img"></p>
<p>第二步：建立urls，导入include模块，各种导入，看下图</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015257097-658719102.png" alt="img"></p>
<p>注意事项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^admin&#x2F;&#39;, admin.site.urls),    </span><br><span class="line">    url(r&#39;^app01&#x2F;&#39;, include(app01_urls)),</span><br><span class="line">    url(r&#39;^app02&#x2F;&#39;, include(app02_urls)),</span><br><span class="line">]</span><br><span class="line"># 在总路由^app01&#x2F;后面千万不能添加$,否则无法找到</span><br></pre></td></tr></table></figure>

<p>补充：简写写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 将导入和路由对应关系全部拿掉，用app.urls的方法</span><br><span class="line">    # from app01 import urls as app01_urls</span><br><span class="line">    # from app02 import urls as app02_urls</span><br><span class="line">    # url(r&#39;^app01&#x2F;&#39;,include(app01_urls)),</span><br><span class="line">    # url(r&#39;^app02&#x2F;&#39;,include(app02_urls))</span><br><span class="line">    </span><br><span class="line">    # 简写</span><br><span class="line">    url(r&#39;^app01&#x2F;&#39;,include(&#39;app01.urls&#39;)),</span><br><span class="line">    url(r&#39;^app02&#x2F;&#39;,include(&#39;app02.urls&#39;))</span><br></pre></td></tr></table></figure>

<h3 id="5-名称空间（了解）"><a href="#5-名称空间（了解）" class="headerlink" title="5.名称空间（了解）"></a>5.名称空间（了解）</h3><p>问题：如果在不同的app中的路由对应关系中添加了相同的name，那么在反向解析的时候能否准确找到</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015313343-1932884372.png" alt="img"></p>
<p>结果是一定的，不能准确找到，那如何解决这个问题？</p>
<p><strong>可以再主路由对应列表中添加namespace属性</strong>，如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">url(r&#39;^app01&#x2F;&#39;, include(&#39;app01.urls&#39;, namespace&#x3D;&#39;app01&#39;))</span><br><span class="line">url(r&#39;^app02&#x2F;&#39;, include(&#39;app02.urls&#39;, namespace&#x3D;&#39;app02&#39;))</span><br><span class="line">后端解析</span><br><span class="line">reverse(&#39;app01:id&#39;)</span><br><span class="line">reverse(&#39;app02:id&#39;)</span><br><span class="line"></span><br><span class="line">前端解析</span><br><span class="line">&#123;% url &#39;app01:index&#39; %&#125;</span><br><span class="line">&#123;% url &#39;app02:index&#39; %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何避免使用这种方法？</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 # 在给路由与视图函数起别名(name的名字)的时候只需要保证永远不出现冲突的情况即可</span><br><span class="line">2 # 通常情况下我们推荐期别名的时候加上当前应用的应用名前缀</span><br><span class="line">3 #例如</span><br><span class="line">4 url(r&#39;^index&#x2F;&#39;,views.index,name&#x3D;&#39;app01_index&#39;)</span><br><span class="line">5 url(r&#39;^index&#x2F;&#39;,views.index,name&#x3D;&#39;app02_index&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="6-虚拟环境"><a href="#6-虚拟环境" class="headerlink" title="6.虚拟环境"></a>6.虚拟环境</h3><p>为什么使用虚拟环境？</p>
<p>我们想做到针对不同的项目 只安装项目所需要的功能模块 项目用不到的一概不装 来避免加载资源时的消耗</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015319807-385254209.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015329861-74562135.png" alt="img"></p>
<p>注意：这次创建需要用以前创立好的虚拟环境来创立</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015350849-487608561.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虚拟环境就类似于一个纯净的python解释器环境</span><br><span class="line">每创建一个虚拟幻境就类似于你重新下载一个python解释器</span><br><span class="line">另外虚拟环境不推荐使用太多，可以创建几个玩一玩，否则占用资源</span><br></pre></td></tr></table></figure>

<h3 id="7-DJango版本区别"><a href="#7-DJango版本区别" class="headerlink" title="7.DJango版本区别"></a>7.DJango版本区别</h3><p><strong>路由层：</strong></p>
<ul>
<li>用的是url，第一个参数是正则表达式</li>
<li>2.x和3.x用的path，第一个参数不是正则表达式，写的是什么就匹配什么，精确匹配</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.x版本</span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^admin&#x2F;&#39;, admin.site.urls),</span><br><span class="line">]</span><br><span class="line">2.x和3.x版本</span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">   path(&#39;admin&#x2F;&#39;, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>如果觉得path不好用 2.x、3.x给你提供了一个跟url一样的功能 re_path 等价于1.x里面的url功能</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015405563-1384343011.png" alt="img"></p>
<p>虽然path不支持正则表达式 但是它给你提供了五种默认的转换器</p>
<ul>
<li>str:匹配除了路径分隔符（/）之外的非空字符串，这是默认的形式</li>
<li>int:匹配正整数，包含0。</li>
<li>slug,匹配字母、数字以及横杠、下划线组成的字符串。</li>
<li>uuid,匹配格式化的uuid，如 075194d3-6885-417e-a8a8-6c931e272f00。</li>
<li>path,匹配任何非空字符串，包含了路径分隔符（/）（不能用？）</li>
</ul>
<p>除了默认的五种转换器之外 还支持你自定义转换器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 class MonthConverter:</span><br><span class="line">2         regex&#x3D;&#39;\d&#123;2&#125;&#39; # 属性名必须为regex</span><br><span class="line">3     </span><br><span class="line">4     def to_python(self, value):</span><br><span class="line">5         return int(value)</span><br><span class="line">6 </span><br><span class="line">7     def to_url(self, value):</span><br><span class="line">8         return value # 匹配的regex是两个数字，返回的结果也必须是两个数字</span><br></pre></td></tr></table></figure>

<h3 id="8-伪静态"><a href="#8-伪静态" class="headerlink" title="8.伪静态"></a>8.伪静态</h3><p>伪静态 url以.html结尾 给人的感觉好像是这个文件是写死的 内容不会轻易的改变 伪静态</p>
<p>为了提高你的网站被搜索引擎收藏的力度 提供网站的SEO查询效率</p>
<p>但是 无论你怎么做优化 都抗不过RMB玩家</p>
<h2 id="四-视图层"><a href="#四-视图层" class="headerlink" title="四.视图层"></a>四.视图层</h2><p>1)JsonResponse</p>
<p>视图函数必须要返回一个HttpResponse对象，因为比如这三板斧都是直接或间接的继承HTTresponse</p>
<ul>
<li>HttpResponse</li>
</ul>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015411423-503214024.png" alt="img"></p>
<ul>
<li>render</li>
</ul>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015418697-1926595043.png" alt="img"></p>
<ul>
<li>redirect</li>
</ul>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015423686-1432951746.png" alt="img"></p>
<p><strong>JsonResponse</strong></p>
<p>前后端数据交互</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from django.http import JsonResponse</span><br><span class="line">def xxx(request):</span><br><span class="line">    user_dict &#x3D; &#123;&#39;username&#39;:&#39;jason&#39;,&#39;password&#39;:&#39;123&#39;&#125;</span><br><span class="line">    json_str&#x3D;json.dumps(user_dict)</span><br><span class="line">    return HttpResponse(json_str)</span><br></pre></td></tr></table></figure>

<p>若添加中文进去,就会发生自动转码的事情，如下图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from django.http import JsonResponse</span><br><span class="line">def xxx(request):</span><br><span class="line">    user_dict &#x3D; &#123;&#39;username&#39;:&#39;jason好帅哦 我好喜欢!&#39;,&#39;password&#39;:&#39;123&#39;&#125;</span><br><span class="line">    json_str&#x3D;json.dumps(user_dict)</span><br><span class="line">    return HttpResponse(json_str)</span><br></pre></td></tr></table></figure>

<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015441969-103073430.png" alt="img"></p>
<p>原因：</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1843708/202001/1843708-20200107015452327-509882785.png" alt="img"></p>
<p>所以只要将ensure_ascii修改成False即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json_str &#x3D; json.dumps(user_dict,ensure_ascii&#x3D;False)</span><br></pre></td></tr></table></figure>

<p>也可以使用JsonResponse</p>
<h3 id="return-JsonResponse-user-dict-json-dumps-params-‘ensure-ascii’-False"><a href="#return-JsonResponse-user-dict-json-dumps-params-‘ensure-ascii’-False" class="headerlink" title="return JsonResponse(user_dict,json_dumps_params={‘ensure_ascii’:False})"></a>return JsonResponse(user_dict,json_dumps_params={‘ensure_ascii’:False})</h3><p>若是一个列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l &#x3D; [1,2,3,4,5,6,7,8,9,]</span><br><span class="line">return JsonResponse(l,safe&#x3D;False)  # 序列化非字典格式数据 需要将safe改为False</span><br></pre></td></tr></table></figure>

<h2 id="forml表单"><a href="#forml表单" class="headerlink" title="forml表单"></a>forml表单</h2><p>1.必须做的事<br>　　method必须是post<br>　　enctype必须是formdata<br>2.暂时需要做的<br>　　提交post请求需要将中间件里面的一个csrfmiddleware注释掉</p>
<p>后端如何获取用户上传的文件<br>　　file_obj = request.FILES.get(‘前端input框name属性值’)<br>　　file_obj.name # 文件名<br>　　for line in file_obj:<br>　　print(line)</p>
<p># django中推荐以下写法<br>　　for chunk in file_obj.chunks():<br>　　print(chunk)</p>
<h2 id="render原理"><a href="#render原理" class="headerlink" title="render原理"></a>render原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def ab_render(request):</span><br><span class="line">　　temp &#x3D; Template(&quot;&lt;h1&gt;&#123;&#123; user_dict &#125;&#125;&#123;&#123; user_dict.username &#125;&#125;&#123;&#123; user_dict.password &#125;&#125;&lt;&#x2F;h1&gt;&quot;)</span><br><span class="line">　　user_dict &#x3D; Context(&#123;&#39;user_dict&#39;:&#123;&#39;username&#39;:&#39;jason&#39;,&#39;password&#39;:123&#125;&#125;)</span><br><span class="line">　　res &#x3D; temp.render(user_dict)</span><br><span class="line">　　return HttpResponse(res)</span><br></pre></td></tr></table></figure>

<p>补充：视图函数不一定是函数，也有可能是类</p>
<p>FBV:基于函数的视图<br>CBV:基于类的视图</p>
<p>CBV基本写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from django.views import View</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyLogin(View):</span><br><span class="line">        def get(self,request):</span><br><span class="line">            return render(request,&#39;login.html&#39;)</span><br><span class="line">        def post(self,request):</span><br><span class="line">            return HttpResponse(&#39;我是类里面的post方法&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url(r&#39;^login&#x2F;&#39;,views.MyLogin.as_view())</span><br></pre></td></tr></table></figure>

<p>朝login提交get请求会自动执行MyLogin里面的get方法<br>而提交post请求也会自动执行MyLogin里面的post方法<br>为什么MyLogin针对不同的请求方法能够自动执行对应的方法</p>
<p>研究源码的突破口<br>url(r’^login/‘,views.MyLogin.as_view())</p>
<p>猜想</p>
<p>as_view要么是类里面定义的普通函数 @staticmethod<br>要么是类里面定义的绑定给类的方法 @classmethod<br>看源码发现是绑定给类的方法@classonlymethod，变成类绑定方法，并且as_view返回的是一个view函数<br>url(r’^login/‘,views.MyLogin.as_view())<br>等价于<br>url(r’^login/‘,views.MyLogin.view)<br>FBV和VBV在路由匹配上是一样的，都是路由与函数内存地址的对应关系<br>并且这个view函数引用了外部的类，他就是一个闭包函数，这个方法给自己定义一些属性，返回一个self.dispatch，我们都知道对象.属性的查找顺序是先查找对象自己的，再查找类的，然后再查找父类的，这里吗就会按顺序找到父类view 的dispatch方法<br>dispatch方法中会先判断请求方式是不是默认的八个请求方式：get，post，put。patch，delete，head，options，trace<br>然后通过反射getattr从我们自己写的类的对象中找请求方式，没有就会报错，该请求方式不允许，有就会调用这个方法并执行，这就是为什么cbv模式下能够自动执行我们定义的方法</p>
<p><img src="https://img2020.cnblogs.com/blog/1843708/202005/1843708-20200528004835109-1203781986.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/15/Django%E6%A1%86%E6%9E%B6%E8%B7%AF%E7%94%B1%E5%B1%82%E5%92%8C%E8%A7%86%E5%9B%BE%E5%B1%82/" data-id="ckd3f9dvz000avkut4frs2ri8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Django/" rel="tag">Django</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/12/16/Django%E6%A1%86%E6%9E%B6%E6%A8%A1%E6%9D%BF%E5%B1%82/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Django框架模板层
        
      </div>
    </a>
  
  
    <a href="/2018/12/09/Django%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Django框架基础配置</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django/" rel="tag">Django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">网络和并发编程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Django/" style="font-size: 16.67px;">Django</a> <a href="/tags/MySQL/" style="font-size: 13.33px;">MySQL</a> <a href="/tags/Python/" style="font-size: 20px;">Python</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">网络和并发编程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/02/Django%E6%A1%86%E6%9E%B6%E4%B9%8BAjax/">Django框架之Ajax</a>
          </li>
        
          <li>
            <a href="/2018/12/27/Django%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%9E%8B%E5%B1%82%E5%B8%B8%E7%94%A8%E5%AD%97%E6%AE%B5%E5%92%8C%E4%BA%8B%E7%89%A9%E6%93%8D%E4%BD%9C/">Django框架模型层常用字段和事物操作</a>
          </li>
        
          <li>
            <a href="/2018/12/19/Django%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%9E%8B%E5%B1%82%E5%92%8CORM/">Django框架模型层和ORM</a>
          </li>
        
          <li>
            <a href="/2018/12/16/Django%E6%A1%86%E6%9E%B6%E6%A8%A1%E6%9D%BF%E5%B1%82/">Django框架模板层</a>
          </li>
        
          <li>
            <a href="/2018/12/15/Django%E6%A1%86%E6%9E%B6%E8%B7%AF%E7%94%B1%E5%B1%82%E5%92%8C%E8%A7%86%E5%9B%BE%E5%B1%82/">Django框架路由层和视图层</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Mr Jiang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>