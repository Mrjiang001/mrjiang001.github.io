<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>并发编程基础 | Mr Jiang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="并发编程1) 操作系统发展史1.1 穿孔卡片 - 读取数据速度特别慢 CPU的利用率极低 单用户(一份代码)使用  1.2 批处理 读取数据速度特别慢  CPU的利用率极低  联机（多份代码）使用  效率还是很低   1.3 脱机批处理（现代操作系统的设计原理） 读取数据速度提高 CPU的利用率提高 每次运行期间发出I&#x2F;O请求后后,高速 的cpu便会处于空闲  2)多道技术(基于单核背景下产生的)">
<meta property="og:type" content="article">
<meta property="og:title" content="并发编程基础">
<meta property="og:url" content="http://yoursite.com/2018/11/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Mr Jiang">
<meta property="og:description" content="并发编程1) 操作系统发展史1.1 穿孔卡片 - 读取数据速度特别慢 CPU的利用率极低 单用户(一份代码)使用  1.2 批处理 读取数据速度特别慢  CPU的利用率极低  联机（多份代码）使用  效率还是很低   1.3 脱机批处理（现代操作系统的设计原理） 读取数据速度提高 CPU的利用率提高 每次运行期间发出I&#x2F;O请求后后,高速 的cpu便会处于空闲  2)多道技术(基于单核背景下产生的)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://user-images.githubusercontent.com/57135669/88485351-c6cc7e80-cfa7-11ea-85de-7b83fac73242.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/57135669/88485355-c92ed880-cfa7-11ea-9860-fc5d13052db8.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/57135669/88485366-d4820400-cfa7-11ea-8848-e70f2ef5cecd.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/57135669/88485358-ce8c2300-cfa7-11ea-801a-35c60fefcc4e.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/57135669/88485359-cf24b980-cfa7-11ea-9a64-1be5254ff1ee.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/57135669/88485360-cfbd5000-cfa7-11ea-8cfe-2739add1d085.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/57135669/88485361-d0ee7d00-cfa7-11ea-877e-4418dc005bd1.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/57135669/88485362-d21faa00-cfa7-11ea-8b1f-31da80ec0e79.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/57135669/88485363-d2b84080-cfa7-11ea-8dd5-33101161be6f.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/57135669/88485364-d350d700-cfa7-11ea-88b1-49c4cc3cf756.png">
<meta property="article:published_time" content="2018-11-28T17:09:46.000Z">
<meta property="article:modified_time" content="2020-07-26T17:27:50.835Z">
<meta property="article:author" content="Mr Jiang">
<meta property="article:tag" content="网络和并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/57135669/88485351-c6cc7e80-cfa7-11ea-85de-7b83fac73242.png">
  
    <link rel="alternate" href="/atom.xml" title="Mr Jiang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mr Jiang</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">头发还够，那就再多学点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-并发编程基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2018-11-28T17:09:46.000Z" itemprop="datePublished">2018-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      并发编程基础
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="1-操作系统发展史"><a href="#1-操作系统发展史" class="headerlink" title="1) 操作系统发展史"></a>1) 操作系统发展史</h3><h4 id="1-1-穿孔卡片"><a href="#1-1-穿孔卡片" class="headerlink" title="1.1 穿孔卡片 -"></a>1.1 穿孔卡片 -</h4><ul>
<li>读取数据速度特别慢</li>
<li>CPU的利用率极低</li>
<li>单用户(一份代码)使用</li>
</ul>
<h4 id="1-2-批处理"><a href="#1-2-批处理" class="headerlink" title="1.2 批处理"></a>1.2 批处理</h4><ul>
<li><p>读取数据速度特别慢</p>
</li>
<li><p>CPU的利用率极低</p>
</li>
<li><p>联机（多份代码）使用</p>
</li>
<li><p>效率还是很低</p>
</li>
</ul>
<h4 id="1-3-脱机批处理（现代操作系统的设计原理）"><a href="#1-3-脱机批处理（现代操作系统的设计原理）" class="headerlink" title="1.3 脱机批处理（现代操作系统的设计原理）"></a>1.3 脱机批处理（现代操作系统的设计原理）</h4><ul>
<li>读取数据速度提高</li>
<li>CPU的利用率提高</li>
<li>每次运行期间发出I/O请求后后,高速 的cpu便会处于空闲</li>
</ul>
<h3 id="2-多道技术-基于单核背景下产生的"><a href="#2-多道技术-基于单核背景下产生的" class="headerlink" title="2)多道技术(基于单核背景下产生的)"></a>2)多道技术(基于单核背景下产生的)</h3><h4 id="单道-串行"><a href="#单道-串行" class="headerlink" title="单道:(串行)"></a>单道:(串行)</h4><ul>
<li>比如: a,b程序同时需要使用cpu，会让a程序先使用，b等待a使用完毕后，b才能使用cpu。</li>
</ul>
<h4 id="多道"><a href="#多道" class="headerlink" title="多道:"></a>多道:</h4><ul>
<li>比如: a,b程序需要使用cpu，a先使用，b等待a，直到a进入“IO或执行时间过长” a会（切换 + 保存状态），然后b可以使用cpu，待b执行遇到 “IO或执行时间过长” 再将cpu执行权限交给a，直到两个程序结束。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">多路复用:</span><br><span class="line"><span class="comment"># 空间上的复用（*******）:多个程序使用一个CPU。</span></span><br><span class="line">将内存分为几部分，每个部分放入一个程序，这样，同一时间内存中就有了多道程序</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">空间上的复用最大的问题是：程序之间的内存必须分割，这种分割需要在硬件层面实现，由操作系统控制。如果内存彼此不分割，则一个程序可以访问另外一个程序的内存，</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">首先丧失的是安全性，比如你的qq程序可以访问操作系统的内存，这意味着你的qq可以拿到操作系统的所有权限。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">其次丧失的是稳定性，某个程序崩溃时有可能把别的程序的内存也给回收了，比方说把操作系统的内存给回收了，则操作系统崩溃。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">时间上的复用（*******）:即切换 + 保存状态</span><br><span class="line">当一个程序在等待I/O时，另一个程序可以使用cpu，如果内存中可以同时存放足够多的作业，则cpu的利用率可以接近<span class="number">100</span>%，类似于我们小学数学所学的统筹方法。（操作系统采用了多道技术后，可以控制进程的切换，或者说进程之间去争抢cpu的执行权限。这种切换不仅会在一个进程遇到io时进行，一个进程占用cpu时间过长也会切换，或者说被操作系统夺走cpu的执行权限）</span><br><span class="line">    </span><br><span class="line"><span class="number">1</span>) 当执行程序遇到IO时，操作系统会将CPU的执行权限剥夺。</span><br><span class="line">优点: CPU的执行效率提高</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>) 当执行程序执行时间过长时，操作系统会将CPU的执行权限剥夺。    </span><br><span class="line">缺点: 程序的执行效率低</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    特点：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　（1）多路性。若干个用户同时使用一台计算机。微观上看是各用户轮流使用计算机；宏观上看是各用户并行工作。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　（2）交互性。用户可根据系统对请求的响应结果，进一步向系统提出新的请求。这种能使用户与系统进行人机对话的工作方式，明显地有别于批处理系统，因而，分时系统又被称为交互式系统。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　（3）独立性。用户之间可以相互独立操作，互不干扰。系统保证各用户程序运行的完整性，不会发生相互混淆或破坏现象。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　（4）及时性。系统可对用户的输入及时作出响应。分时系统性能的主要指标之一是响应时间，它是指：从终端发出命令到系统予以应答所需的时间。</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/57135669/88485351-c6cc7e80-cfa7-11ea-85de-7b83fac73242.png" alt="并1"><br><img src="https://user-images.githubusercontent.com/57135669/88485355-c92ed880-cfa7-11ea-9860-fc5d13052db8.png" alt="并2"></p>
<h4 id="并发与并行-（-）"><a href="#并发与并行-（-）" class="headerlink" title="并发与并行:（***）"></a>并发与并行:（<strong>***</strong>）</h4><p><strong>并发:</strong> 在单核（一个cpu）情况下，当执行两个a,b程序时，a先执行，当a遇到IO时，b开始争抢cpu的执行权限，再让b执行，他们看起像同时运行。</p>
<p><strong>并行:</strong> 在多核（多个cpu）的情况下，当执行两个a,b程序时，a与b同时执行。他们是真正意义上的同时运行。</p>
<p><strong>面试题:</strong> 在单核情况下能否实现并行？ 不行</p>
<h3 id="3-进程"><a href="#3-进程" class="headerlink" title="3) 进程"></a>3) 进程</h3><h4 id="1-什么是进程？"><a href="#1-什么是进程？" class="headerlink" title="1.什么是进程？"></a>1.什么是进程？</h4><p>正在进行的一个过程或者说一个任务。是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p>
<p>进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个抽象概念,所有多道程序设计操作系统都建立在进程的基础上。</p>
<h4 id="2-进程与程序"><a href="#2-进程与程序" class="headerlink" title="2.进程与程序:"></a>2.进程与程序:</h4><ul>
<li>程序: 一对代码文件。</li>
<li>进程: 执行代码的过程，称之为进程。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举个例子</span></span><br><span class="line">想象一位tom猫正在给他的宿敌jerry做奶油蛋糕。</span><br><span class="line"></span><br><span class="line">他有做奶油蛋糕的食谱及所需的所有原料:面粉、鸡蛋、奶油等。</span><br><span class="line"></span><br><span class="line">在这个比喻中：</span><br><span class="line"></span><br><span class="line">做蛋糕的食谱就是程序</span><br><span class="line"></span><br><span class="line">tom猫就是处理器(cpu)</span><br><span class="line"></span><br><span class="line">而做蛋糕的各种原料就是输入数据</span><br><span class="line"></span><br><span class="line">进程就是tom阅读食谱、取来各种原料以及烘制蛋糕等一系列动作的总和</span><br><span class="line"></span><br><span class="line">现在假设tom猫的主人站在门外需要tom去开门</span><br><span class="line"></span><br><span class="line">tom想了想，给主人开门的任务比给jerry鼠做蛋糕的任务更重要，于是tom立马先记下照着食谱做到第几步(保存进程的当前状态)，然后跑去给主人开门。这里，我们看到处理机从一个进程(做蛋糕)切换到另一个高优先级的进程(开门)，每个进程拥有各自的程序(食谱和开锁)。开门之后，tom又回来从他离开时的那一步继续做蛋糕</span><br><span class="line"></span><br><span class="line">需要强调的是：同一个程序执行两次，那也是两个进程，比如打开快播，虽然都是同一个软件，但是一个可以播放苍井空,一个可以播放饭岛爱,分别做不同的事情也不会混乱</span><br></pre></td></tr></table></figure>

<h4 id="3-进程调度-了解"><a href="#3-进程调度-了解" class="headerlink" title="3 进程调度: (了解)"></a>3 进程调度: (了解)</h4><ul>
<li><p>先来先服务调度算法(了解)</p>
<p>比如程序 a，b，若a先来，则让a先服务，待a服务完毕后，b再服务。</p>
<p>缺点: 执行效率低。</p>
</li>
<li><p>短作业优先调度算法(了解)</p>
<p>执行时间越短，则先先调度。</p>
<p>缺点: 导致执行时间长的程序，需要等待所有时间短的程序执行完毕后，才能执行。</p>
<p>现代操作系统的进程调度算法: 时间片轮转法 + 多级反馈队列 (知道)</p>
</li>
<li><p>时间片轮转法</p>
</li>
</ul>
<p>时间片轮转(Round Robin，RR)法的基本思路是让每个进程在就绪队列中的等待时间与享受服务的时间成比例。在时间片轮转法中，需要将CPU的处理时间分成固定大小的时间片，例如，几十毫秒至几百毫秒。如果一个进程在被调度选中之后用完了系统规定的时间片，但又未完成要求的任务，则它自行释放自己所占有的CPU而排到就绪队列的末尾，等待下一次调度。同时，进程调度程序又去调度当前就绪队列中的第一个进程。</p>
<p>比如同时有10个程序需要执行，操作系统会给你10秒，然后时间片轮转法会将10秒分成10等分。</p>
<ul>
<li>多级反馈队列:</li>
</ul>
<p>1级队列: 优先级最高，先执行次队列中程序。</p>
<p>2级队列: 优先级以此类推</p>
<p>3级队列:</p>
<ul>
<li><pre><code class="python">前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。
而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。
(<span class="number">1</span>) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+<span class="number">1</span>个队列的时间片要比第i个队列的时间片长一倍。
(<span class="number">2</span>) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。

(<span class="number">3</span>) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第<span class="number">1</span>～(i<span class="number">-1</span>)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第<span class="number">1</span>～(i<span class="number">-1</span>)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 4) 同步与异步(*******):</span><br><span class="line"></span><br><span class="line">同步与异步 指的是 “提交任务的方式”。</span><br><span class="line"></span><br><span class="line">同步（串行）: 两个a，b程序都要提交并执行，假如a先提交执行，b必须等a执行完毕后，才能提交任务。</span><br></pre></td></tr></table></figure>
一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">异步（并发）: 两个a，b程序都要提交并执行，假如a先提交并执行，b无需等a执行完毕，就可以直接提交任务。</span><br></pre></td></tr></table></figure>
不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 5)阻塞与非阻塞(*******):</span><br><span class="line"></span><br><span class="line">- 阻塞（等待）: 凡是遇到IO都会阻塞。</span><br><span class="line"></span><br><span class="line">  IO: input &#x2F;output , time.sleep(3) , 文件的读写 , 数据的传输</span><br><span class="line"></span><br><span class="line">- 非阻塞 (不等待) : 除了IO都是非阻塞 （比如: 从1+1开始计算到100万这种计算过程不是阻塞）</span><br><span class="line"></span><br><span class="line">#### 6) 进程的三种状态（*******）:</span><br><span class="line"></span><br><span class="line">- 就绪态: 同步与异步</span><br><span class="line">- 运行态: 程序的执行时间过长 ----&gt; 将程序返回给就绪态(这是非阻塞)</span><br><span class="line">- 阻塞态: 遇到IO</span><br><span class="line"></span><br><span class="line">![并3](https:&#x2F;&#x2F;user-images.githubusercontent.com&#x2F;57135669&#x2F;88485365-d3e96d80-cfa7-11ea-9ab0-36f3669b1421.png)</span><br><span class="line"></span><br><span class="line">**面试题:** 阻塞与同步是一样的吗？非阻塞与异步是一样的吗？</span><br><span class="line"></span><br><span class="line">答:</span><br><span class="line">IO密集型:这时阻塞与同步是不一样的,</span><br><span class="line">计算密集型:这是阻塞与同步看起来一样,但是本质上仍然不一样</span><br><span class="line">同步与异步:提交任务的方式</span><br><span class="line"></span><br><span class="line">阻塞与非阻塞: 进程的状态。</span><br><span class="line"></span><br><span class="line">异步非阻塞: ----&gt; cpu的利用率最大化!</span><br><span class="line"></span><br><span class="line">#### 7) 创建进程的方式:</span><br><span class="line"></span><br><span class="line">但凡是硬件，都需要有操作系统去管理，只要有操作系统，就有进程的概念，就需要有创建进程的方式，一些操作系统只为一个应用程序设计，比如扫地机器人，一旦启动，所有的进程都已经存在。</span><br><span class="line"></span><br><span class="line">　　而对于通用系统（跑很多应用程序），需要有系统运行过程中创建或撤销进程的能力，主要分为4中形式创建新的进程：</span><br><span class="line"></span><br><span class="line">　　1. 系统初始化（查看进程linux中用ps命令，windows中用任务管理器，前台进程负责与用户交互，后台运行的进程与用户无关，运行在后台并且只在需要时才唤醒的进程，称为守护进程，如电子邮件、web页面、新闻、打印）</span><br><span class="line"></span><br><span class="line">　　2. 一个进程在运行过程中开启了子进程（如nginx开启多进程，os.fork,subprocess.Popen等）</span><br><span class="line"></span><br><span class="line">　　3. 用户的交互式请求，而创建一个新进程（如用户用鼠标双击任意一款软件图片:qq,微信,暴风影音等）</span><br><span class="line"></span><br><span class="line">　　4. 一个批处理作业的初始化（只在大型机的批处理系统中应用）</span><br><span class="line"></span><br><span class="line">　　无论哪一种，新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的。　</span><br><span class="line"></span><br><span class="line">##### **multiprocess模块**</span><br><span class="line"></span><br><span class="line">仔细说来，multiprocess不是一个模块而是python中一个操作、管理进程的包。 之所以叫multi是取自multiple的多功能的意思,在这个包中几乎包含了和进程有关的所有子模块。由于提供的子模块非常多，为了方便大家归类记忆，我将这部分大致分为四个部分：创建进程部分，进程同步部分，进程池部分，进程之间数据共享。</span><br><span class="line"></span><br><span class="line">##### **Process类创建进程的两种方式**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">from multiprocessing import Process</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 方式1: 直接调用Process</span><br><span class="line">def task(name):  # 任务  # name &#x3D;&#x3D; &#39;jason_sb&#39;</span><br><span class="line">    print(f&#39;start...&#123;name&#125;的子进程&#39;)</span><br><span class="line">    time.sleep(3)</span><br><span class="line">    print(f&#39;end...&#123;name&#125;的子进程&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    # target&#x3D;任务(函数地址) ---&gt; 创建一个子进程</span><br><span class="line">    # 异步提交了三个任务</span><br><span class="line">    p_obj1 &#x3D; Process(target&#x3D;task, args&#x3D;(&#39;jason_sb&#39;, ))</span><br><span class="line">    p_obj1.start()  # 告诉操作系统，去创建一个子进程</span><br><span class="line">    p_obj1.join()  # 告诉主进程，等待子进程结束后，再结束</span><br><span class="line"></span><br><span class="line">    p_obj2 &#x3D; Process(target&#x3D;task, args&#x3D;(&#39;sean_sb&#39;, ))</span><br><span class="line">    p_obj2.start()  # 告诉操作系统，去创建一个子进程</span><br><span class="line">    p_obj2.join()  # 告诉主进程，等待子进程结束后，再结束</span><br><span class="line"></span><br><span class="line">    p_obj3 &#x3D; Process(target&#x3D;task, args&#x3D;(&#39;大饼_sb&#39;, ))</span><br><span class="line">    p_obj3.start()  # 告诉操作系统，去创建一个子进程</span><br><span class="line">    p_obj3.join()  # 告诉主进程，等待子进程结束后，再结束</span><br><span class="line"></span><br><span class="line">    print(&#39;正在执行当前主进程...&#39;)</span><br><span class="line"></span><br><span class="line">    list1 &#x3D; []</span><br><span class="line"></span><br><span class="line">    for line in range(10):</span><br><span class="line">        p_obj &#x3D; Process(target&#x3D;task, args&#x3D;(&#39;jason_sb&#39;,))</span><br><span class="line">        p_obj.start()</span><br><span class="line">        list1.append(p_obj)</span><br><span class="line"></span><br><span class="line">    for obj in list1:</span><br><span class="line">        obj.join()</span><br><span class="line"></span><br><span class="line">    print(&#39;主进程&#39;)</span><br><span class="line"># 方式二:</span><br><span class="line">from multiprocessing import Process</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyProcess(Process):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(f&#39;start...&#123;self.name&#125;的子进程&#39;)</span><br><span class="line">        time.sleep(3)</span><br><span class="line">        print(f&#39;end...&#123;self.name&#125;的子进程&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    list1 &#x3D; []</span><br><span class="line"></span><br><span class="line">    for line in range(10):</span><br><span class="line">        obj &#x3D; MyProcess()</span><br><span class="line">        obj.start()</span><br><span class="line">        list1.append(obj)</span><br><span class="line"></span><br><span class="line">    for obj in list1:</span><br><span class="line">        obj.join()</span><br><span class="line"></span><br><span class="line">    print(&#39;主进程...&#39;)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>‘’’<br>强调:在Windows操作系统中由于没有fork(linux操作系统中创建进程的机制)，在创建子进程的时候会自动 import 启动它的这个文件，而在 import 的时候又执行了整个文件。因此如果将process()直接写在文件中就会无限递归创建子进程报错。所以必须把创建子进程的部分使用if <strong>name ==‘</strong>main’ 判断保护起来，import 的时候 ，就不会递归运行了。</p>
<p>‘’’</p>
<h4 id="8-回收进程的两种方式"><a href="#8-回收进程的两种方式" class="headerlink" title="8)回收进程的两种方式"></a>8)回收进程的两种方式</h4><ul>
<li>join让主进程等待子进程结束，并回收子进程资源，主进程再结束并回收资源。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span>  Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'start...'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'end...'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 告诉操作系统帮你开启一个新的进程</span></span><br><span class="line">    p.start()</span><br><span class="line">    <span class="comment"># 告诉操作系统等待子进程结束</span></span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'主进程结束'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>主进程 “正常结束” ，子进程与主进程一并被回收资源。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二种</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"> 主进程 “正常结束” ，子进程与主进程一并被回收资源。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span>  Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'start...'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'end...'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=task)</span><br><span class="line">    <span class="comment"># 告诉操作系统帮你开启一个新的进程</span></span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'主进程结束'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="9-僵尸进程与孤儿进程（了解）"><a href="#9-僵尸进程与孤儿进程（了解）" class="headerlink" title="9)僵尸进程与孤儿进程（了解）"></a>9)僵尸进程与孤儿进程（了解）</h4><ul>
<li><p><strong>僵尸进程 (有坏处):</strong></p>
<p>在子进程结束后，主进程没有正常结束, 子进程PID不会被回收。 <strong>缺点:</strong> 操作系统中的PID号是有限的，如有子进程PID号无法正常回收，则会占用PID号,造成资源浪费,若PID号满了,则无法创建新的进程。</p>
<p>词语解释:PID</p>
<p>进程pID（英语：processID）、PID）是大多数操作系统的内核用于唯一标识进程的一个数值。（简言之，就是进程的绰号。）这一数值可以作为许多函数调用的参数，以使调整进程优先级、kill(命令)进程之类的进程控制行为成为可能。</p>
</li>
<li><p><strong>孤儿进程（没有坏处）</strong>:</p>
<p>在子进程没有结束时，主进程没有“正常结束”, 子进程PID不会被回收。</p>
<p><strong>操作系统优化机制（孤儿院）:</strong> 当主进程意外终止，操作系统会检测是否有正在运行的子进程，会他们放入孤儿院中，让操作系统帮你自动回收。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">僵尸进程</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在子进程中调用可以拿到子进程对象,.pid可以获取pid号</span></span><br><span class="line"><span class="comment"># 在主进程中调用可以拿到主进程对象,.pid可以获取pid号</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> current_process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># current_porcess模块中的current_process().pid和os模块的os.getpid()</span></span><br><span class="line"><span class="comment"># 都可以获取子进程和主进程的pid号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">f'start...<span class="subst">&#123;current_process().pid&#125;</span>'</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">f'end.....<span class="subst">&#123;current_process().pid&#125;</span>'</span>)</span><br><span class="line">    print(<span class="string">'子进程结束了'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=task)</span><br><span class="line"></span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f'进入主进程的IO---&gt;<span class="subst">&#123;current_process().pid&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f'进入主进程的IO---&gt;<span class="subst">&#123;os.getpid()&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主进程结束</span></span><br><span class="line">    print(<span class="string">'主进程结束...'</span>)</span><br><span class="line">    print(<span class="string">f'查看主进程<span class="subst">&#123;os.getpid()&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为了让主程序异常报错结束</span></span><br><span class="line">    f = open(<span class="string">'tank.txt'</span>)</span><br><span class="line">    print(<span class="string">f'查看主进程<span class="subst">&#123;os.getpid()&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="10-守护进程"><a href="#10-守护进程" class="headerlink" title="10)守护进程"></a>10)守护进程</h4><p>当主进程结束时，子进程也必须结束，并回收。</p>
<p>主进程创建守护进程</p>
<p>　　其一：守护进程会在主进程代码执行结束后就终止</p>
<p>　　其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children</p>
<p>注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myprocess</span><span class="params">(Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,person)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.person = person</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(os.getpid(),self.name)</span><br><span class="line">        print(<span class="string">'%s正在和女主播聊天'</span> %self.person)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p=Myprocess(<span class="string">'炮王'</span>)</span><br><span class="line">p.daemon=<span class="literal">True</span>  <span class="comment"># 一定要在p.start()前设置,设置p为守护进程,禁止p创建子进程,并且父进程代码执行结束,p即终止运行</span></span><br><span class="line">p.start()</span><br><span class="line">time.sleep(<span class="number">10</span>)  <span class="comment"># 在sleep时查看进程id对应的进程ps -ef|grep id</span></span><br><span class="line">print(<span class="string">'主'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个迷惑性的例子</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">123</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"end123"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">456</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"end456"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1=Process(target=foo)</span><br><span class="line">p2=Process(target=bar)</span><br><span class="line"></span><br><span class="line">p1.daemon=<span class="literal">True</span></span><br><span class="line">p1.start()</span><br><span class="line">p2.start()</span><br><span class="line">time.sleep(<span class="number">0.1</span>)</span><br><span class="line">print(<span class="string">"main-------"</span>)<span class="comment">#打印该行则主进程代码结束,则守护进程p1应该被终止.#可能会有p1任务执行的打印信息123,因为主进程打印main----时,p1也执行了,但是随即被终止.</span></span><br></pre></td></tr></table></figure>

<h4 id="11-进程间数据隔离"><a href="#11-进程间数据隔离" class="headerlink" title="11)进程间数据隔离"></a>11)进程间数据隔离</h4><p><strong>进程隔离</strong>是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术</p>
<p>这个技术是为了避免进程A写入进程B的情况发生。 进程的隔离实现，使用了虚拟地址空间。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B</p>
<p>进程隔离的安全性通过禁止进程间内存的访问可以方便实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line">n=<span class="number">100</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n  </span><br><span class="line">    n=<span class="number">0</span></span><br><span class="line">    print(<span class="string">'子进程内: '</span>,n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p=Process(target=work)</span><br><span class="line">    p.start()</span><br><span class="line">    print(<span class="string">'主进程内: '</span>,n)</span><br></pre></td></tr></table></figure>

<h4 id="12-进程互斥锁-multiprocess-Lock"><a href="#12-进程互斥锁-multiprocess-Lock" class="headerlink" title="12)进程互斥锁(multiprocess.Lock)"></a>12)进程互斥锁(multiprocess.Lock)</h4><p>进程之间数据不共享,但是共享同一套文件系统,所以访问同一个文件,或同一个打印终端,是没有问题的,</p>
<p>而共享带来的是竞争，竞争带来的结果就是错乱，如何控制，就是加锁处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件db的内容为：&#123;"count":1&#125;</span></span><br><span class="line"><span class="comment">#注意一定要用双引号，不然json无法识别</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Lock</span><br><span class="line"><span class="keyword">import</span> time,json,random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">()</span>:</span></span><br><span class="line">    dic=json.load(open(<span class="string">'db'</span>))</span><br><span class="line">    print(<span class="string">'\033[43m剩余票数%s\033[0m'</span> %dic[<span class="string">'count'</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">    dic=json.load(open(<span class="string">'db'</span>))</span><br><span class="line">    time.sleep(<span class="number">0.1</span>) <span class="comment">#模拟读数据的网络延迟</span></span><br><span class="line">    <span class="keyword">if</span> dic[<span class="string">'count'</span>] &gt;<span class="number">0</span>:</span><br><span class="line">        dic[<span class="string">'count'</span>]-=<span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">0.2</span>) <span class="comment">#模拟写数据的网络延迟</span></span><br><span class="line">        json.dump(dic,open(<span class="string">'db'</span>,<span class="string">'w'</span>))</span><br><span class="line">        print(<span class="string">'\033[43m购票成功\033[0m'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">()</span>:</span></span><br><span class="line">    search()</span><br><span class="line">    get()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>): <span class="comment">#模拟并发100个客户端抢票</span></span><br><span class="line">        p=Process(target=task)</span><br><span class="line">        p.start()</span><br><span class="line"><span class="comment"># 引发问题:数据写入错乱</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">互斥锁保证数据安全</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Lock</span><br><span class="line"><span class="keyword">import</span> time,json,random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">()</span>:</span></span><br><span class="line">    dic=json.load(open(<span class="string">'db'</span>))</span><br><span class="line">    print(<span class="string">'\033[43m剩余票数%s\033[0m'</span> %dic[<span class="string">'count'</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">    dic=json.load(open(<span class="string">'db'</span>))</span><br><span class="line">    time.sleep(random.random())  <span class="comment"># 模拟读数据的网络延迟</span></span><br><span class="line">    <span class="keyword">if</span> dic[<span class="string">'count'</span>] &gt;<span class="number">0</span>:</span><br><span class="line">        dic[<span class="string">'count'</span>]-=<span class="number">1</span></span><br><span class="line">        time.sleep(random.random())  <span class="comment"># 模拟写数据的网络延迟</span></span><br><span class="line">        json.dump(dic,open(<span class="string">'db'</span>,<span class="string">'w'</span>))</span><br><span class="line">        print(<span class="string">'\033[32m购票成功\033[0m'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'\033[31m购票失败\033[0m'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(lock)</span>:</span></span><br><span class="line">    search()</span><br><span class="line">    lock.acquire()  <span class="comment"># 将买票这一环节由并发变成了串行，牺牲了运行效率但是保证了数据的安全</span></span><br><span class="line">    get()</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):  <span class="comment"># 模拟并发100个客户端抢票</span></span><br><span class="line">        p=Process(target=task,args=(lock,))</span><br><span class="line">        p.start()</span><br><span class="line">总结:加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，</span><br><span class="line">    </span><br><span class="line">    但牺牲了速度却保证了数据安全。</span><br><span class="line"></span><br><span class="line">问题:虽然可以用文件共享数据显示进程间数据通信但问题是</span><br><span class="line"></span><br><span class="line">效率低(共享数据基于文件，而文件是硬盘上的数据)</span><br><span class="line">需要自己加锁处理</span><br></pre></td></tr></table></figure>

<h4 id="13-队列"><a href="#13-队列" class="headerlink" title="13)队列:"></a>13)队列:</h4><p>FIFO:先进先出简写，指的就是队列<br>FILO:先进后出，指的就是堆栈</p>
<p>先进先出 进—-》 [3, 2, 1] —-》 出 1, 2, 3 ,先存放的数据，就先取出来。</p>
<p>相当于一个第三方的管道，可以存放数据。</p>
<p>应用: 让进程之间数据进行交互。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">基本用法</span><br><span class="line">Queue([maxsize]) <span class="comment"># 创建共享的进程队列 队列底层使用管道和锁定实现。</span></span><br><span class="line"><span class="comment"># 参数 ：maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">代码实现</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line">q=Queue(<span class="number">3</span>)  <span class="comment"># 创建一个最大只能容纳3个数据的队列</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">常用方法</span></span><br><span class="line"><span class="string">put ,get ,put_nowait,get_nowait,full,empty</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">q.put(<span class="number">3</span>)  <span class="comment"># 往队列中存放数据</span></span><br><span class="line">q.put(<span class="number">3</span>)</span><br><span class="line">q.put(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q.put(<span class="number">3</span>)  <span class="comment"># 如果队列已经满了，程序就会停在这里，等待数据被别人取走，再将数据放入队列。如果队列中的数据一直不被取走，程序就会永远停在这里。</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    q.put_nowait(<span class="number">3</span>) <span class="comment"># 可以使用put_nowait，如果队列满了不会阻塞，但是会因为队列满了而报错。</span></span><br><span class="line"><span class="keyword">except</span>:  <span class="comment"># 因此我们可以用一个try语句来处理这个错误。这样程序不会一直阻塞下去，但是会丢掉这个消息。</span></span><br><span class="line">    print(<span class="string">'队列已经满了'</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此，我们再放入数据之前，可以先看一下队列的状态，如果已经满了，就不继续put了。</span></span><br><span class="line">print(q.full())  <span class="comment"># 判断队列中数据是否已存放满了</span></span><br><span class="line"></span><br><span class="line">print(q.get())  <span class="comment"># 从队列中获取数据</span></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(q.get()) <span class="comment"># 同put方法一样，如果队列已经空了，那么继续取就会出现阻塞。</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    q.get_nowait(<span class="number">3</span>) <span class="comment"># 可以使用get_nowait，如果队列满了不会阻塞，但是会因为没取到值而报错。</span></span><br><span class="line"><span class="keyword">except</span>: <span class="comment"># 因此我们可以用一个try语句来处理这个错误。这样程序不会一直阻塞下去。</span></span><br><span class="line">    print(<span class="string">'队列已经空了'</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">print(q.empty())  <span class="comment"># 判断队列中数据是否已经被全部取出</span></span><br><span class="line">基于队列实现进程间通信</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(q)</span>:</span></span><br><span class="line">    q.put(<span class="string">'hello'</span>)  <span class="comment">#调用主函数中p进程传递过来的进程参数 put函数为向队列中添加一条数据。</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()  <span class="comment"># 创建一个Queue对象</span></span><br><span class="line">    p = Process(target=f, args=(q,)) <span class="comment">#创建一个进程</span></span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get())  <span class="comment"># 从队列中获取数据</span></span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue,Process</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(q)</span>:</span></span><br><span class="line">    q.put(<span class="string">'hello big baby!'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(q.get())</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    p = Process(target=producer,args=(q,))</span><br><span class="line">    p.start()</span><br><span class="line">    p1 = Process(target=consumer,args=(q,))</span><br><span class="line">    p1.start()</span><br></pre></td></tr></table></figure>

<h4 id="13-IPC机制（进程间实现通信）"><a href="#13-IPC机制（进程间实现通信）" class="headerlink" title="13)IPC机制（进程间实现通信）"></a>13)IPC机制（进程间实现通信）</h4><p>Inter-Process Communication</p>
<p>我们知道进程之间数据是相互隔离的，要想实现进程间的通信(IPC机制),就必须借助于一些技术才可以，比如multiprocessing模块中的：队列和管道，这两种方式都是可以实现进程间数据传输的，由于队列是管道+锁的方式实现，所以我们着重研究队列即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> JoinableQueue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task1</span><span class="params">(q)</span>:</span></span><br><span class="line">    x = <span class="number">100</span></span><br><span class="line">    q.put(x)</span><br><span class="line">    print(<span class="string">'添加数据'</span>)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(q.get())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task2</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="comment"># 想要在task2中获取task1的x</span></span><br><span class="line">    res = q.get()</span><br><span class="line">    print(<span class="string">f'获取的数据是<span class="subst">&#123;res&#125;</span>'</span>)</span><br><span class="line">    q.put(<span class="number">9527</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 产生队列</span></span><br><span class="line">    q = JoinableQueue(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 产生两个不同的子进程</span></span><br><span class="line">    p1 = Process(target=task1, args=(q, ))</span><br><span class="line">    p2 = Process(target=task2, args=(q, ))</span><br><span class="line"></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">基于队列实现进程间通信   </span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(q)</span>:</span></span><br><span class="line">    q.put(<span class="string">'hello'</span>)  <span class="comment">#调用主函数中p进程传递过来的进程参数 put函数为向队列中添加一条数据。</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()  <span class="comment"># 创建一个Queue对象</span></span><br><span class="line">    p = Process(target=f, args=(q,)) <span class="comment">#创建一个进程</span></span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get())  <span class="comment"># 从队列中获取数据</span></span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue,Process</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(q)</span>:</span></span><br><span class="line">    q.put(<span class="string">'hello big baby!'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(q.get())</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    p = Process(target=producer,args=(q,))</span><br><span class="line">    p.start()</span><br><span class="line">    p1 = Process(target=consumer,args=(q,))</span><br><span class="line">    p1.start()</span><br></pre></td></tr></table></figure>

<h4 id="14-生产者消费者模型"><a href="#14-生产者消费者模型" class="headerlink" title="14)生产者消费者模型"></a>14)生产者消费者模型</h4><p><strong>生产者消费者模型</strong></p>
<p>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。</p>
<p><strong>什么是生产者消费者模式</strong></p>
<p>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据(做包子的)之后不用等待消费者(吃包子的)处理，直接扔给阻塞队列(盘子)，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p>
<p><strong>为什么要使用生产者和消费者模式</strong></p>
<p>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">基于队列实现生产者消费者模型</span><br><span class="line"><span class="comment"># 第一个例子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> time,random,os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res=q.get()</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        print(<span class="string">'%s 吃 %s'</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        res=<span class="string">'包子%s'</span> %i</span><br><span class="line">        q.put(res)</span><br><span class="line">        print(<span class="string">'%s 生产了 %s'</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q=Queue()</span><br><span class="line">    <span class="comment">#生产者们:即厨师们</span></span><br><span class="line">    p1=Process(target=producer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#消费者们:即吃货们</span></span><br><span class="line">    c1=Process(target=consumer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#开始</span></span><br><span class="line">    p1.start()</span><br><span class="line">    c1.start()</span><br><span class="line">    print(<span class="string">'主'</span>)</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个例子</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> JoinableQueue</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产者: 生产数据 ---》 队列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(name, food, q)</span>:</span></span><br><span class="line">    msg = <span class="string">f'<span class="subst">&#123;name&#125;</span> 生产了 <span class="subst">&#123;food&#125;</span> 食物'</span></span><br><span class="line">    <span class="comment"># 生产一个食物，添加到队列中</span></span><br><span class="line">    q.put(food)</span><br><span class="line">    print(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者: 使用数据 《---  列队</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">customer</span><span class="params">(name, q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">            <span class="comment"># 若报错，则跳出循环</span></span><br><span class="line">            food = q.get_nowait()</span><br><span class="line">            msg = <span class="string">f'<span class="subst">&#123;name&#125;</span> 吃了 <span class="subst">&#123;food&#125;</span> 食物!'</span></span><br><span class="line">            print(msg)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = JoinableQueue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建两个生产者</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p1 = Process(target=producer, args=(<span class="string">'tank1'</span>, <span class="string">f'Pig饲料<span class="subst">&#123;line&#125;</span>'</span>, q))</span><br><span class="line">        p1.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建两个消费者</span></span><br><span class="line">    c1 = Process(target=customer, args=(<span class="string">'jason'</span>, q))</span><br><span class="line">    c2 = Process(target=customer, args=(<span class="string">'sean'</span>, q))</span><br><span class="line">    c1.start()</span><br><span class="line">    c2.start()</span><br></pre></td></tr></table></figure>

<h3 id="4-线程"><a href="#4-线程" class="headerlink" title="4)线程"></a>4)线程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">线程:</span><br><span class="line">    <span class="number">1.</span>什么是线程？</span><br><span class="line">        进程: 资源单位。</span><br><span class="line">        线程: 执行单位。</span><br><span class="line"></span><br><span class="line">        线程与进程都是虚拟的概念，为了更好表达某种事物。</span><br><span class="line"></span><br><span class="line">        注意: 开启一个进程，一定会自带一个线程，线程才是真正的执行者。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="number">2.</span>为什么要使用线程？</span><br><span class="line">        节省资源的占用。</span><br><span class="line"></span><br><span class="line">        - 开启进程:</span><br><span class="line">            - <span class="number">1</span>) 会产生一个内存空间，申请一块资源。</span><br><span class="line">            - <span class="number">2</span>) 会自带一个主线程</span><br><span class="line">            - <span class="number">3</span>) 开启子进程的速度要比开启子线程的速度慢</span><br><span class="line"></span><br><span class="line">        - 开启线程</span><br><span class="line">            - <span class="number">1</span>) 一个进程内可以开启多个线程，从进程的内存空间中申请执行单位。</span><br><span class="line">            - <span class="number">2</span>) 节省资源。</span><br><span class="line"></span><br><span class="line">        - 开启三个进程:</span><br><span class="line">            - 占用三份内存资源</span><br><span class="line"></span><br><span class="line">        - 开启三个线程:</span><br><span class="line">            - 从一个内存资源中，申请三个小的执行单位</span><br><span class="line"></span><br><span class="line">        - IO密集型用: 多线程</span><br><span class="line">            - IO(时间由用户定):</span><br><span class="line">                - 阻塞: 切换 + 保存状态</span><br><span class="line"></span><br><span class="line">        - 计算密集型用: 多进程</span><br><span class="line">            - 计算(时间由操作系统定):</span><br><span class="line">                - 计算时间很长 ---&gt; 切换 + 保存状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    注意: 进程与进程之间数据是隔离的，线程与线程之间的数据是共享的。</span><br></pre></td></tr></table></figure>

<h4 id="1-什么是线程"><a href="#1-什么是线程" class="headerlink" title="1) 什么是线程"></a>1) 什么是线程</h4><p>在传统操作系统中，每个进程有一个地址空间，而且默认就有一个控制线程</p>
<p>线程顾名思义，就是一条流水线工作的过程，一条流水线必须属于一个车间，一个车间的工作过程是一个进程</p>
<p>车间负责把资源整合到一起，是一个资源单位，而一个车间内至少有一个流水线</p>
<p>流水线的工作需要电源，电源就相当于cpu</p>
<p>所以，<strong>进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源集合），而线程才是cpu上的执行单位。</strong></p>
<p><strong>多线程（即多个控制线程）</strong>:在一个进程中存在多个控制线程，多个控制线程共享该进程的地址空间，相当于一个车间内有多条流水线，都共用一个车间的资源。</p>
<p>例如，北京地铁与上海地铁是不同的进程，而北京地铁里的13号线是一个线程，北京地铁所有的线路共享北京地铁所有的资源，比如所有的乘客可以被所有线路拉。</p>
<h4 id="2-线程的创建开销小"><a href="#2-线程的创建开销小" class="headerlink" title="2) 线程的创建开销小"></a>2) 线程的创建开销小</h4><p>创建进程的开销要远大于线程？</p>
<p>如果我们的软件是一个工厂，该工厂有多条流水线，流水线工作需要电源，电源只有一个即cpu（单核cpu）</p>
<p>一个车间就是一个进程，一个车间至少一条流水线（一个进程至少一个线程）</p>
<p>创建一个进程，就是创建一个车间（申请空间，在该空间内建至少一条流水线）</p>
<p>而建线程，就只是在一个车间内造一条流水线，无需申请空间，所以创建开销小</p>
<p><strong>进程之间是竞争关系，线程之间是协作关系？</strong></p>
<p>车间直接是竞争/抢电源的关系，竞争（不同的进程直接是竞争关系，是不同的程序员写的程序运行的，迅雷抢占其他进程的网速，360把其他进程当做病毒干死）<br>一个车间的不同流水线式协同工作的关系（同一个进程的线程之间是合作关系，是同一个程序写的程序内开启动，迅雷内的线程是合作关系，不会自己干自己）</p>
<h4 id="3-线程与进程的区别"><a href="#3-线程与进程的区别" class="headerlink" title="3)线程与进程的区别"></a>3)线程与进程的区别</h4><p>线程共享创建它的进程的地址空间;进程有自己的地址空间。</p>
<p>线程可以直接访问其进程的数据段;进程有自己的父进程数据段的副本。</p>
<p>线程可以直接与进程中的其他线程通信;进程必须使用进程间通信来与同级进程通信。</p>
<p>新线程很容易创建;新的进程需要父进程的复制。</p>
<p>线程可以对同一进程的线程进行相当大的控制;流程只能对子流程进行控制。</p>
<p>主线程的更改(取消、优先级更改等)可能会影响进程中其他线程的行为;对父进程的更改不会影响子进程。</p>
<h4 id="4-为何要用多线程"><a href="#4-为何要用多线程" class="headerlink" title="4)为何要用多线程"></a>4)为何要用多线程</h4><p>多线程指的是，在一个进程中开启多个线程，简单的讲：如果多个任务共用一块地址空间，那么必须在一个进程内开启多个线程。详细的讲分为4点：</p>
<ol>
<li>多线程共享一个进程的地址空间</li>
<li>线程比进程更轻量级，线程比进程更容易创建可撤销，在许多操作系统中，创建一个线程比创建一个进程要快10-100倍，在有大量线程需要动态和快速修改时，这一特性很有用</li>
<li>若多个线程都是cpu密集型的，那么并不能获得性能上的增强，但是如果存在大量的计算和大量的I/O处理，拥有多个线程允许这些活动彼此重叠运行，从而会加快程序执行的速度。</li>
<li>在多cpu系统中，为了最大限度的利用多核，可以开启多个线程，比开进程开销要小的多。（这一条并不适用于python）</li>
</ol>
<h4 id="5-多线程的应用举例"><a href="#5-多线程的应用举例" class="headerlink" title="5)多线程的应用举例"></a>5)多线程的应用举例</h4><p><img src="https://user-images.githubusercontent.com/57135669/88485366-d4820400-cfa7-11ea-8848-e70f2ef5cecd.png" alt="并4"></p>
<p>开启一个字处理软件进程，该进程肯定需要办不止一件事情，比如监听键盘输入，处理文字，定时自动将文字保存到硬盘，这三个任务操作的都是同一块数据，因而不能用多进程。只能在一个进程里并发地开启三个线程,如果是单线程，那就只能是，键盘输入时，不能处理文字和自动保存，自动保存时又不能输入和处理文字。</p>
<h4 id="6-经典的线程模型（了解）"><a href="#6-经典的线程模型（了解）" class="headerlink" title="6)经典的线程模型（了解）"></a>6)经典的线程模型（了解）</h4><p>多个线程共享同一个进程的地址空间中的资源，是对一台计算机上多个进程的模拟，有时也称线程为轻量级的进程</p>
<p>　　而对一台计算机上多个进程，则共享物理内存、磁盘、打印机等其他物理资源。</p>
<p>　　多线程的运行也多进程的运行类似，是cpu在多个线程之间的快速切换。</p>
<p><img src="https://user-images.githubusercontent.com/57135669/88485358-ce8c2300-cfa7-11ea-801a-35c60fefcc4e.png" alt="并5"></p>
<p>不同的进程之间是充满敌意的，彼此是抢占、竞争cpu的关系，如果迅雷会和QQ抢资源。而同一个进程是由一个程序员的程序创建，所以同一进程内的线程是合作关系，一个线程可以访问另外一个线程的内存地址，大家都是共享的，一个线程干死了另外一个线程的内存，那纯属程序员脑子有问题。</p>
<p>　　类似于进程，每个线程也有自己的堆栈</p>
<p><img src="https://user-images.githubusercontent.com/57135669/88485359-cf24b980-cfa7-11ea-9a64-1be5254ff1ee.png" alt="并6"></p>
<p>不同于进程，线程库无法利用时钟中断强制线程让出CPU，可以调用thread_yield运行线程自动放弃cpu，让另外一个线程运行。</p>
<p>　　</p>
<p>　　线程通常是有益的，但是带来了不小程序设计难度，线程的问题是：</p>
<p>　　1. 父进程有多个线程，那么开启的子线程是否需要同样多的线程</p>
<p>　　　如果是，那么附近中某个线程被阻塞，那么copy到子进程后，copy版的线程也要被阻塞吗，想一想nginx的多线程模式接收用户连接。</p>
<p>　　2. 在同一个进程中，如果一个线程关闭了问题，而另外一个线程正准备往该文件内写内容呢？</p>
<p>如果一个线程注意到没有内存了，并开始分配更多的内存，在工作一半时，发生线程切换，新的线程也发现内存不够用了，又开始分配更多的内存，这样内存就被分配了多次，这些问题都是多线程编程的典型问题，需要仔细思考和设计。</p>
<h4 id="7-POSIX线程（了解）"><a href="#7-POSIX线程（了解）" class="headerlink" title="7) POSIX线程（了解）"></a>7) POSIX线程（了解）</h4><p>为了实现可移植的线程程序,IEEE在IEEE标准1003.1c中定义了线程标准，它定义的线程包叫Pthread。大部分UNIX系统都支持该标准，简单介绍如下</p>
<p><img src="https://user-images.githubusercontent.com/57135669/88485360-cfbd5000-cfa7-11ea-8cfe-2739add1d085.png" alt="并7"></p>
<h4 id="8-在用户空间实现的线程（了解）"><a href="#8-在用户空间实现的线程（了解）" class="headerlink" title="8) 在用户空间实现的线程（了解）"></a>8) 在用户空间实现的线程（了解）</h4><p>线程的实现可以分为两类：用户级线程(User-Level Thread)和内核线线程(Kernel-Level Thread)，后者又称为内核支持的线程或轻量级进程。在多线程操作系统中，各个系统的实现方式并不相同，在有的系统中实现了用户级线程，有的系统中实现了内核级线程。</p>
<p>用户级线程内核的切换由用户态程序自己控制内核切换,不需要内核干涉，少了进出内核态的消耗，但不能很好的利用多核Cpu,目前Linux pthread大体是这么做的。</p>
<p><img src="https://user-images.githubusercontent.com/57135669/88485361-d0ee7d00-cfa7-11ea-877e-4418dc005bd1.png" alt="并8"></p>
<h4 id="9-在内核空间实现的线程（了解）"><a href="#9-在内核空间实现的线程（了解）" class="headerlink" title="9)在内核空间实现的线程（了解）"></a>9)在内核空间实现的线程（了解）</h4><p>内核级线程:切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态；可以很好的利用smp，即利用多核cpu。windows线程就是这样的。</p>
<p><img src="https://user-images.githubusercontent.com/57135669/88485362-d21faa00-cfa7-11ea-8b1f-31da80ec0e79.png" alt="并9"></p>
<h4 id="10-用户级与内核级线程的对比（了解）"><a href="#10-用户级与内核级线程的对比（了解）" class="headerlink" title="10)用户级与内核级线程的对比（了解）"></a>10)用户级与内核级线程的对比（了解）</h4><p><strong>一： 以下是用户级线程和内核级线程的区别：</strong></p>
<ol>
<li>内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。</li>
<li>用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。</li>
<li>用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。</li>
<li>在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。</li>
<li>用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。</li>
</ol>
<p><strong>二： 内核线程的优缺点</strong></p>
<p>　　<strong>优点：</strong></p>
<ol>
<li>当有多个处理机时，一个进程的多个线程可以同时执行。</li>
</ol>
<p>　　<strong>缺点：</strong></p>
<ol>
<li>由内核进行调度。</li>
</ol>
<p><strong>三： 用户进程的优缺点</strong></p>
<p>　　<strong>优点：</strong></p>
<ol>
<li>线程的调度不需要内核直接参与，控制简单。</li>
<li>可以在不支持线程的操作系统中实现。</li>
<li>创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。</li>
<li>允许每个进程定制自己的调度算法，线程管理比较灵活。</li>
<li>线程能够利用的表空间和堆栈空间比内核级线程多。</li>
<li>同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。另外，页面失效也会产生同样的问题。</li>
</ol>
<p>　　<strong>缺点：</strong></p>
<ol>
<li>资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用</li>
</ol>
<h4 id="11-混合实现（了解）"><a href="#11-混合实现（了解）" class="headerlink" title="11) 混合实现（了解）"></a>11) 混合实现（了解）</h4><p>用户级与内核级的多路复用，内核同一调度内核线程，每个内核线程对应n个用户线程</p>
<p><img src="https://user-images.githubusercontent.com/57135669/88485363-d2b84080-cfa7-11ea-8dd5-33101161be6f.png" alt="并10"></p>
<h4 id="12-守护线程"><a href="#12-守护线程" class="headerlink" title="12)守护线程"></a>12)守护线程</h4><p>无论是进程还是线程，都遵循：守护xxx会等待主xxx运行完毕后被销毁</p>
<p>需要强调的是：运行完毕并非终止运行</p>
<h4 id="1-对主进程来说，运行完毕指的是主进程代码运行完毕"><a href="#1-对主进程来说，运行完毕指的是主进程代码运行完毕" class="headerlink" title="1.对主进程来说，运行完毕指的是主进程代码运行完毕"></a>1.对主进程来说，运行完毕指的是主进程代码运行完毕</h4><h4 id="2-对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才算运行完毕"><a href="#2-对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才算运行完毕" class="headerlink" title="2.对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才算运行完毕"></a>2.对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才算运行完毕</h4><p>详细解释：</p>
<h4 id="1-主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）-然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源-否则会产生僵尸进程-，才会结束，"><a href="#1-主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）-然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源-否则会产生僵尸进程-，才会结束，" class="headerlink" title="1 主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）,然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束，"></a>1 主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）,然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束，</h4><h4 id="2-主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束。"><a href="#2-主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束。" class="headerlink" title="2 主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束。"></a>2 主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束。</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">(name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'%s say hello'</span> %name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t=Thread(target=sayhi,args=(<span class="string">'egon'</span>,))</span><br><span class="line">    t.setDaemon(<span class="literal">True</span>) <span class="comment">#必须在t.start()之前设置</span></span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'主线程'</span>)</span><br><span class="line">    print(t.is_alive())</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    主线程</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">迷惑人的例子</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">123</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"end123"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">456</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"end456"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1=Thread(target=foo)</span><br><span class="line">t2=Thread(target=bar)</span><br><span class="line"></span><br><span class="line">t1.daemon=<span class="literal">True</span></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">print(<span class="string">"main-------"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="13-线程池"><a href="#13-线程池" class="headerlink" title="13)线程池"></a>13)线程池</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"> <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># pool只能创建100个线程</span></span><br><span class="line"> pool = ThreadPoolExecutor(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(line)</span>:</span></span><br><span class="line">     print(line)</span><br><span class="line">     time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">     <span class="keyword">for</span> line <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">        pool.submit(task, line)</span><br></pre></td></tr></table></figure>

<h4 id="14-其他方法"><a href="#14-其他方法" class="headerlink" title="14)其他方法"></a>14)其他方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br></pre></td><td class="code"><pre><span class="line">一 开启线程的两种方式</span><br><span class="line"><span class="comment">#方式一</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">(name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'%s say hello'</span> %name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t=Thread(target=sayhi,args=(<span class="string">'egon'</span>,))</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">'主线程'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#方式二</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sayhi</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.name=name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">'%s say hello'</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = Sayhi(<span class="string">'tony'</span>)</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">'主线程'</span>)</span><br><span class="line"><span class="number">343434</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二 在一个进程下开启多个线程与在一个进程下开启多个子进程的区别</span><br><span class="line">开启速度</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#在主进程下开启线程</span></span><br><span class="line">    t=Thread(target=work)</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">'主线程/主进程'</span>)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    打印结果:</span></span><br><span class="line"><span class="string">    hello</span></span><br><span class="line"><span class="string">    主线程/主进程</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#在主进程下开启子进程</span></span><br><span class="line">    t=Process(target=work)</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">'主线程/主进程'</span>)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    打印结果:</span></span><br><span class="line"><span class="string">    主线程/主进程</span></span><br><span class="line"><span class="string">    hello</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">进程编号</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>,os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#part1:在主进程下开启多个线程,每个线程都跟主进程的pid一样</span></span><br><span class="line">    t1=Thread(target=work)</span><br><span class="line">    t2=Thread(target=work)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    print(<span class="string">'主线程/主进程pid'</span>,os.getpid())</span><br><span class="line"></span><br><span class="line">    <span class="comment">#part2:开多个进程,每个进程都有不同的pid</span></span><br><span class="line">    p1=Process(target=work)</span><br><span class="line">    p2=Process(target=work)</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    print(<span class="string">'主线程/主进程pid'</span>,os.getpid())</span><br><span class="line">同一进程内的线程共享数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span>  threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    n=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># n=100</span></span><br><span class="line">    <span class="comment"># p=Process(target=work)</span></span><br><span class="line">    <span class="comment"># p.start()</span></span><br><span class="line">    <span class="comment"># p.join()</span></span><br><span class="line">    <span class="comment"># print('主',n) #毫无疑问子进程p已经将自己的全局的n改成了0,但改的仅仅是它自己的,查看父进程的n仍然为100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    n=<span class="number">1</span></span><br><span class="line">    t=Thread(target=work)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line">    print(<span class="string">'主'</span>,n) <span class="comment">#查看结果为0,因为同一进程内的线程之间共享进程内的数据</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">四 练习</span><br><span class="line"></span><br><span class="line">练习<span class="number">1</span></span><br><span class="line">多线程并发的socket服务端</span><br><span class="line"></span><br><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">s.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(conn)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data=conn.recv(<span class="number">1024</span>)</span><br><span class="line">        print(data)</span><br><span class="line">        conn.send(data.upper())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn,addr=s.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        p=threading.Thread(target=action,args=(conn,))</span><br><span class="line">        p.start()</span><br><span class="line">客户端</span><br><span class="line"></span><br><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=input(<span class="string">'&gt;&gt;: '</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> msg:<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    s.send(msg.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    data=s.recv(<span class="number">1024</span>)</span><br><span class="line">    print(data)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">练习<span class="number">2</span></span><br><span class="line">三个任务，一个接收用户输入，一个将用户输入的内容格式化成大写，一个将格式化后的结果存入文件</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">msg_l=[]</span><br><span class="line">format_l=[]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg=input(<span class="string">'&gt;&gt;: '</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> msg:<span class="keyword">continue</span></span><br><span class="line">        msg_l.append(msg)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_msg</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> msg_l:</span><br><span class="line">            res=msg_l.pop()</span><br><span class="line">            format_l.append(res.upper())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> format_l:</span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">'db.txt'</span>,<span class="string">'a'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                res=format_l.pop()</span><br><span class="line">                f.write(<span class="string">'%s\n'</span> %res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t1=Thread(target=talk)</span><br><span class="line">    t2=Thread(target=format_msg)</span><br><span class="line">    t3=Thread(target=save)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t3.start()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">五 线程相关的其他方法</span><br><span class="line">Thread实例对象的方法</span><br><span class="line">  <span class="comment"># isAlive(): 返回线程是否活动的。</span></span><br><span class="line">  <span class="comment"># getName(): 返回线程名。</span></span><br><span class="line">  <span class="comment"># setName(): 设置线程名。</span></span><br><span class="line"></span><br><span class="line">threading模块提供的一些方法：</span><br><span class="line">  <span class="comment"># threading.currentThread(): 返回当前的线程变量。</span></span><br><span class="line">  <span class="comment"># threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</span></span><br><span class="line">  <span class="comment"># threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(threading.current_thread().getName())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#在主进程下开启线程</span></span><br><span class="line">    t=Thread(target=work)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">    print(threading.current_thread().getName())</span><br><span class="line">    print(threading.current_thread()) <span class="comment">#主线程</span></span><br><span class="line">    print(threading.enumerate()) <span class="comment">#连同主线程在内有两个运行的线程</span></span><br><span class="line">    print(threading.active_count())</span><br><span class="line">    print(<span class="string">'主线程/主进程'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    打印结果:</span></span><br><span class="line"><span class="string">    MainThread</span></span><br><span class="line"><span class="string">    &lt;_MainThread(MainThread, started 140735268892672)&gt;</span></span><br><span class="line"><span class="string">    [&lt;_MainThread(MainThread, started 140735268892672)&gt;, &lt;Thread(Thread-1, started 123145307557888)&gt;]</span></span><br><span class="line"><span class="string">    主线程/主进程</span></span><br><span class="line"><span class="string">    Thread-1</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">主线程等待子线程结束</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">(name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'%s say hello'</span> %name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t=Thread(target=sayhi,args=(<span class="string">'egon'</span>,))</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line">    print(<span class="string">'主线程'</span>)</span><br><span class="line">    print(t.is_alive())</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    egon say hello</span></span><br><span class="line"><span class="string">    主线程</span></span><br><span class="line"><span class="string">    False</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">八 死锁现象与递归锁</span><br><span class="line">进程也有死锁与递归锁，在进程那里忘记说了，放到这里一切说了额</span><br><span class="line"></span><br><span class="line">所谓死锁： 是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程，如下就是死锁</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">mutexA=Lock()</span><br><span class="line">mutexB=Lock()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.func1()</span><br><span class="line">        self.func2()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span></span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(<span class="string">'\033[41m%s 拿到A锁\033[0m'</span> %self.name)</span><br><span class="line"></span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(<span class="string">'\033[42m%s 拿到B锁\033[0m'</span> %self.name)</span><br><span class="line">        mutexB.release()</span><br><span class="line"></span><br><span class="line">        mutexA.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(self)</span>:</span></span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(<span class="string">'\033[43m%s 拿到B锁\033[0m'</span> %self.name)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(<span class="string">'\033[44m%s 拿到A锁\033[0m'</span> %self.name)</span><br><span class="line">        mutexA.release()</span><br><span class="line"></span><br><span class="line">        mutexB.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        t=MyThread()</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Thread-1 拿到A锁</span></span><br><span class="line"><span class="string">Thread-1 拿到B锁</span></span><br><span class="line"><span class="string">Thread-1 拿到B锁</span></span><br><span class="line"><span class="string">Thread-2 拿到A锁</span></span><br><span class="line"><span class="string">然后就卡住，死锁了</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">解决方法，递归锁，在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock。</span><br><span class="line"></span><br><span class="line">这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁：</span><br><span class="line"></span><br><span class="line">mutexA=mutexB=threading.RLock() <span class="comment">#一个线程拿到锁，counter加1,该线程内又碰到加锁的情况，则counter继续加1，这期间所有其他线程都只能等待，等待该线程释放所有锁，即counter递减到0为止</span></span><br><span class="line">九 信号量Semaphore</span><br><span class="line">同进程的一样</span><br><span class="line"></span><br><span class="line">Semaphore管理一个内置的计数器，</span><br><span class="line">每当调用acquire()时内置计数器<span class="number">-1</span>；</span><br><span class="line">调用release() 时内置计数器+<span class="number">1</span>；</span><br><span class="line">计数器不能小于<span class="number">0</span>；当计数器为<span class="number">0</span>时，acquire()将阻塞线程直到其他线程调用release()。</span><br><span class="line"></span><br><span class="line">实例：(同时只有<span class="number">5</span>个线程可以获得semaphore,即可以限制最大连接数为<span class="number">5</span>)：</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Semaphore</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># def func():</span></span><br><span class="line"><span class="comment">#     if sm.acquire():</span></span><br><span class="line"><span class="comment">#         print (threading.currentThread().getName() + ' get semaphore')</span></span><br><span class="line"><span class="comment">#         time.sleep(2)</span></span><br><span class="line"><span class="comment">#         sm.release()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    sm.acquire()</span><br><span class="line">    print(<span class="string">'%s get sm'</span> %threading.current_thread().getName())</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    sm.release()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sm=Semaphore(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">23</span>):</span><br><span class="line">        t=Thread(target=func)</span><br><span class="line">        t.start()</span><br><span class="line">与进程池是完全不同的概念，进程池Pool(<span class="number">4</span>)，最大只能产生<span class="number">4</span>个进程，而且从头到尾都只是这四个进程，不会产生新的，而信号量是产生一堆线程/进程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">十 Event</span><br><span class="line">同进程的一样</span><br><span class="line"></span><br><span class="line">线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其 他线程需要通过判断某个线程的状态来确定自己下一步的操作,这时线程同步问题就会变得非常棘手。为了解决这些问题,我们需要使用threading库中的Event对象。 对象包含一个可由线程设置的信号标志,它允许线程等待某些事件的发生。在 初始情况下,Event对象中的信号标志被设置为假。如果有线程等待一个Event对象, 而这个Event对象的标志为假,那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个Event对象的信号标志设置为真,它将唤醒所有等待这个Event对象的线程。如果一个线程等待一个已经被设置为真的Event对象,那么它将忽略这个事件, 继续执行</span><br><span class="line"></span><br><span class="line">event.isSet()：返回event的状态值；</span><br><span class="line">event.wait()：如果 event.isSet()==<span class="literal">False</span>将阻塞线程；</span><br><span class="line">event.set()： 设置event的状态值为<span class="literal">True</span>，所有阻塞池的线程激活进入就绪状态， 等待操作系统调度；</span><br><span class="line">event.clear()：恢复event的状态值为<span class="literal">False</span>。</span><br><span class="line"><span class="number">55555</span></span><br><span class="line"></span><br><span class="line">例如，有多个工作线程尝试链接MySQL，我们想要在链接前确保MySQL服务正常才让那些工作线程去连接MySQL服务器，如果连接不成功，都会去尝试重新连接。那么我们就可以采用threading.Event机制来协调各个工作线程的连接操作</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Event</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time,random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn_mysql</span><span class="params">()</span>:</span></span><br><span class="line">    count=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> event.is_set():</span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">raise</span> TimeoutError(<span class="string">'链接超时'</span>)</span><br><span class="line">        print(<span class="string">'&lt;%s&gt;第%s次尝试链接'</span> % (threading.current_thread().getName(), count))</span><br><span class="line">        event.wait(<span class="number">0.5</span>)</span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">    print(<span class="string">'&lt;%s&gt;链接成功'</span> %threading.current_thread().getName())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_mysql</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'\033[45m[%s]正在检查mysql\033[0m'</span> % threading.current_thread().getName())</span><br><span class="line">    time.sleep(random.randint(<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">    event.set()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    event=Event()</span><br><span class="line">    conn1=Thread(target=conn_mysql)</span><br><span class="line">    conn2=Thread(target=conn_mysql)</span><br><span class="line">    check=Thread(target=check_mysql)</span><br><span class="line"></span><br><span class="line">    conn1.start()</span><br><span class="line">    conn2.start()</span><br><span class="line">    check.start()</span><br><span class="line">获得cpu数量</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">print(os.cpu_count())</span><br></pre></td></tr></table></figure>

<h4 id="15）GIL-globl-interpreter-lock-全局解释锁"><a href="#15）GIL-globl-interpreter-lock-全局解释锁" class="headerlink" title="15）GIL(globl interpreter lock)全局解释锁"></a>15）GIL(globl interpreter lock)全局解释锁</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">定义：</span></span><br><span class="line"><span class="string">In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple </span></span><br><span class="line"><span class="string">native threads from executing Python bytecodes at once. This lock is necessary mainly </span></span><br><span class="line"><span class="string">because CPython’s memory management is not thread-safe. (However, since the GIL </span></span><br><span class="line"><span class="string">exists, other features have grown to depend on the guarantees that it enforces.)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">结论：在Cpython解释器中，同一个进程下开启的多线程，同一时刻只能有一个线程执行，无法利用多核优势</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/57135669/88485364-d350d700-cfa7-11ea-88b1-49c4cc3cf756.png" alt="并11"></p>
<p><strong>注意：GIL并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念， Python完全可以不依赖于GIL</strong></p>
<p><strong>什么是GIL?</strong></p>
<p>GIL本质就是一个互斥锁，相当于执行权限，每个进程内都会存在一把CIL,同一个进程内多个线程必须抢到GIL之后才能使用Cpytho解释器来执行自己的代码，即同一个进程内的多个线程只能使用并发，无法使用并行</p>
<p><strong>为什么要使用GIL?</strong></p>
<p>因为cpython中的垃圾回收机制不是线程安全的，就是为了数据安全才设置的GIL</p>
<p>GIL全局解释器锁的优缺点:</p>
<p>优点: 保证数据的安全</p>
<p>缺点: 单个进程下，开启多个线程，牺牲执行效率，无法实现并行，只能实现并发。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">IO密集型下使用多线程.</span><br><span class="line">计算密集型下使用多进程.</span><br><span class="line"></span><br><span class="line">IO密集型任务，每个任务<span class="number">4</span>s</span><br><span class="line">    - 单核:</span><br><span class="line">        - 开启线程比进程节省资源。</span><br><span class="line">        </span><br><span class="line">    - 多核:</span><br><span class="line">        - 多线程: </span><br><span class="line">            - 开启<span class="number">4</span>个子线程: <span class="number">16</span>s </span><br><span class="line">            </span><br><span class="line">        - 多进程:</span><br><span class="line">            - 开启<span class="number">4</span>个进程: <span class="number">16</span>s + 申请开启资源消耗的时间</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">计算密集型任务，每个任务<span class="number">4</span>s</span><br><span class="line">    - 单核:</span><br><span class="line">        - 开启线程比进程节省资源。</span><br><span class="line">        </span><br><span class="line">    - 多核:</span><br><span class="line">        - 多线程:</span><br><span class="line">            - 开启<span class="number">4</span>个子线程: <span class="number">16</span>s</span><br><span class="line">            </span><br><span class="line">        - 多进程:</span><br><span class="line">            - 开启多个进程: <span class="number">4</span>s</span><br></pre></td></tr></table></figure>

<h4 id="16-协程"><a href="#16-协程" class="headerlink" title="16)协程"></a>16)协程</h4><p><strong>协程:单线程实现并发</strong></p>
<p>注意:协程是程序员想出来的，操作系统里面只有进程和线程的概念，操作系统调度的是线程</p>
<p>在单线程下实现多个任务遇到IO就切换就可以降低单线程的IO时间，从而最大限度的提升单线程的效率（若不是遇到io，比如遇到计算就切反而会降低效率）</p>
<p>注意：yield并不能解决遇到io就切换的操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey  <span class="comment"># 猴子补丁</span></span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> spawn</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> joinall</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 注意，gevent模块不能识别他本身以外的IO类型,本身time模块已经封装一份在gevent内，可</span></span><br><span class="line"><span class="comment"># 以调用gevent内部的sleep，如果需要其他类型的IO，则需要打一个猴子补丁</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"%s paly 1 "</span>%name)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"%s paly 2 "</span>%name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"%s eat 1"</span>%name)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">"%s eat 2"</span>%name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">time_start = time.time()</span><br><span class="line">g1 = spawn(play, <span class="string">'tank'</span>)</span><br><span class="line">g2 = spawn(play, <span class="string">'sean'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># g1.join()</span></span><br><span class="line"><span class="comment"># g2.join()</span></span><br><span class="line">joinall([g1, g2]) <span class="comment"># 取代join</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'主进程'</span>, time.time()-time_start)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" data-id="ckd3ewqcp001dqwut7ftv3it7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">网络和并发编程</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/12/05/Django%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Django框架简介和安装
        
      </div>
    </a>
  
  
    <a href="/2018/11/25/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">网络编程基础</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django/" rel="tag">Django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">网络和并发编程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Django/" style="font-size: 16.67px;">Django</a> <a href="/tags/MySQL/" style="font-size: 13.33px;">MySQL</a> <a href="/tags/Python/" style="font-size: 20px;">Python</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">网络和并发编程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/16/Django%E6%A1%86%E6%9E%B6%E6%A8%A1%E6%9D%BF%E5%B1%82/">Django框架模板层</a>
          </li>
        
          <li>
            <a href="/2019/01/02/Django%E6%A1%86%E6%9E%B6%E4%B9%8BAjax/">Django框架之Ajax</a>
          </li>
        
          <li>
            <a href="/2018/12/27/Django%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%9E%8B%E5%B1%82%E5%B8%B8%E7%94%A8%E5%AD%97%E6%AE%B5%E5%92%8C%E4%BA%8B%E7%89%A9%E6%93%8D%E4%BD%9C/">Django框架模型层常用字段和事物操作</a>
          </li>
        
          <li>
            <a href="/2018/12/19/Django%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%9E%8B%E5%B1%82%E5%92%8CORM/">Django框架模型层和ORM</a>
          </li>
        
          <li>
            <a href="/2018/12/15/Django%E6%A1%86%E6%9E%B6%E8%B7%AF%E7%94%B1%E5%B1%82%E5%92%8C%E8%A7%86%E5%9B%BE%E5%B1%82/">Django框架路由层和视图层</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Mr Jiang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>